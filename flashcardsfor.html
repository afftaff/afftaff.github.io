<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>French Flashcards</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f2f2f7;
      --card-bg: #ffffff;
      --text: #1c1c1e;
      --accent: #007aff;
      --muted: #8e8e93;
      --border: #e5e5ea;
      --back-face: #f1f3ff;
      
      /* Rating Colors */
      --rate-again: #ff3b30;
      --rate-hard: #ff9500;
      --rate-good: #34c759;
      --rate-easy: #007aff;

      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding: 16px;
      font-size: 16px;
    }

    header {
      text-align: center;
      margin-bottom: 16px;
    }

    h1 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 700;
      opacity: 0.9;
    }

    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
      max-width: 600px;
      margin: 0 auto;
      width: 100%;
    }

    /* --- FLASHCARD STYLES --- */
    .card-stage {
      display: flex;
      flex-direction: column;
      gap: 16px;
      position: relative;
    }

    .meta-top {
      text-align: center;
      font-size: 0.85rem;
      color: var(--muted);
      font-variant-numeric: tabular-nums;
    }

    .flashcard {
      width: 100%;
      height: 50vh; 
      min-height: 320px;
      max-height: 550px;
      perspective: 1000px;
      cursor: pointer;
      -webkit-tap-highlight-color: transparent;
    }

    .flashcard-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      transition: transform 0.5s cubic-bezier(0.4, 0.0, 0.2, 1);
    }

    .flashcard.is-flipped .flashcard-inner {
      transform: rotateY(180deg);
    }

    .flashcard-face {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 24px;
      background: var(--card-bg);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.06);
      backface-visibility: hidden;
      padding: 24px;
      text-align: center;
      border: 1px solid rgba(0,0,0,0.05);
    }

    .flashcard-back {
      background: var(--back-face);
      transform: rotateY(180deg);
    }

    /* --- CONTROLS & CONTENT --- */
    .front-controls {
      margin-bottom: 24px;
      z-index: 10;
    }

    .speak-button {
      background: rgba(0, 122, 255, 0.1); 
      color: var(--accent);
      border: 1px solid rgba(0, 122, 255, 0.2);
      border-radius: 50%;
      width: 80px; 
      height: 80px;
      font-size: 3rem; 
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      box-shadow: 0 4px 10px rgba(0, 122, 255, 0.15);
    }
    
    .speak-button:active { 
      transform: scale(0.9); 
      background: rgba(0, 122, 255, 0.2);
    }

    /* 
       --- BLUR LOGIC --- 
       By default, .front-text is blurred/hidden.
       It only becomes visible when .is-visible is added.
    */
    .front-text {
      font-size: 2.8rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      margin: 0;
      line-height: 1.2;
      padding: 12px 20px;
      border-radius: 16px;

      /* DEFAULT STATE: HIDDEN/BLURRED */
      opacity: 0;
      color: transparent;
      text-shadow: 0 0 35px rgba(0, 0, 0, 0.35); /* Strong blur */
      background: rgba(0,0,0,0.04); /* Light grey patch */
      user-select: none;
      cursor: pointer;
      transition: none;
    }

    /* REVEALED STATE */
    .front-text.is-visible {
      opacity: 1;
      color: var(--text);
      text-shadow: none;
      background: transparent;
      cursor: text;
      user-select: text;
      transition: opacity 0.2s ease 0.12s, color 0.2s ease 0.12s,
        text-shadow 0.2s ease 0.12s, background 0.2s ease 0.12s;
    }

    .back-text {
      font-size: 1.8rem;
      font-weight: 500;
      color: var(--accent);
    }

    .tap-hint {
      position: absolute;
      bottom: 24px;
      font-size: 0.85rem;
      color: var(--muted);
      opacity: 0.7;
    }

    /* --- RATING BUTTONS --- */
    .controls-area {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .rating-btn {
      border: none;
      padding: 16px 4px;
      border-radius: 14px;
      font-weight: 600;
      font-size: 0.95rem;
      cursor: pointer;
      color: white;
      transition: transform 0.1s, opacity 0.2s;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      -webkit-tap-highlight-color: transparent;
    }

    .rating-btn:active { transform: scale(0.96); opacity: 0.9; }
    .rating-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }

    .btn-again { background: var(--rate-again); }
    .btn-hard  { background: var(--rate-hard); }
    .btn-good  { background: var(--rate-good); }
    .btn-easy  { background: var(--rate-easy); }

    /* --- ACCORDIONS --- */
    .accordion-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: auto;
      padding-top: 20px;
    }

    details {
      background: #ffffff;
      border-radius: 12px;
      border: 1px solid var(--border);
      overflow: hidden;
      font-size: 0.9rem;
    }

    summary {
      padding: 14px;
      cursor: pointer;
      font-weight: 600;
      list-style: none;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(255,255,255,0.5);
    }

    summary::-webkit-details-marker { display: none; }
    
    summary::after {
      content: '+';
      font-size: 1.2rem;
      font-weight: 300;
      color: var(--muted);
    }
    
    details[open] summary::after { content: 'âˆ’'; }

    .details-content {
      padding: 14px;
      border-top: 1px solid var(--border);
      color: var(--text);
      line-height: 1.5;
    }

    .queue-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      color: var(--muted);
    }
    
    code {
      background: #eee;
      padding: 2px 6px;
      border-radius: 4px;
      word-break: break-all;
      font-family: monospace;
      font-size: 0.85em;
    }

    @media (max-width: 400px) {
      .controls-area { grid-template-columns: repeat(2, 1fr); }
      .front-text { font-size: 2.2rem; }
      .speak-button { width: 70px; height: 70px; font-size: 2.5rem; }
    }
  </style>
</head>
<body>

  <header>
    <h1>French Flashcards</h1>
  </header>

  <main>
    <section class="card-stage">
      <div class="meta-top" id="progress">Loading...</div>
      
      <div class="flashcard" id="flashcard" role="button" aria-pressed="false" tabindex="0">
        <div class="flashcard-inner">
          <!-- FRONT -->
          <div class="flashcard-face flashcard-front">
            <div class="front-controls">
              <button class="speak-button" type="button" id="speak-button" aria-label="Speak">ðŸ”Š</button>
            </div>
            
            <!-- Default state is now blurred/hidden -->
            <div class="front-text" id="front-text">...</div>
            <div class="tap-hint">Tap card to flip</div>
          </div>
          
          <!-- BACK -->
          <div class="flashcard-face flashcard-back">
            <div class="back-text" id="back-text">...</div>
            <div class="tap-hint">Rate difficulty below</div>
          </div>
        </div>
      </div>
    </section>

    <section class="controls-area">
      <button type="button" data-rating="again" class="rating-btn btn-again">Again</button>
      <button type="button" data-rating="hard" class="rating-btn btn-hard">Hard</button>
      <button type="button" data-rating="good" class="rating-btn btn-good">Good</button>
      <button type="button" data-rating="easy" class="rating-btn btn-easy">Easy</button>
    </section>

    <div class="accordion-group">
      <details>
        <summary>Upcoming Cards <span id="queue-count" style="font-weight:400; color:var(--muted)">(0)</span></summary>
        <div class="details-content">
          <div class="queue-list" id="queue-list"></div>
        </div>
      </details>

      <details>
        <summary>How to add cards</summary>
        <div class="details-content">
          <p style="margin-top:0">Pass cards via the URL using <code>?card=front|back</code>.</p>
          <p><strong>Example:</strong><br>
          <code>flashcards.html?card=bonjour|hello&card=merci|thanks</code></p>
          <p style="margin-bottom:0; font-size:0.85em; color:var(--muted);">Tip: Bookmark the URL with your custom cards to save the deck.</p>
        </div>
      </details>
    </div>
  </main>

  <script>
    const flashcard = document.getElementById("flashcard");
    const frontTextEl = document.getElementById("front-text");
    const backTextEl = document.getElementById("back-text");
    const progressEl = document.getElementById("progress");
    const queueList = document.getElementById("queue-list");
    const queueCountEl = document.getElementById("queue-count");
    const speakButton = document.getElementById("speak-button");
    const ratingButtons = Array.from(document.querySelectorAll("[data-rating]"));
    
    const DEFAULT_TTS_LANG = "fr-FR";
    let preferredVoice = null;

    // --- 1. Load Data ---
    const urlParams = new URLSearchParams(window.location.search);
    const rawCards = urlParams.getAll("card");

    const defaultCards = [
      { frontText: "bonjour", backText: "hello" },
      { frontText: "merci", backText: "thank you" },
      { frontText: "au revoir", backText: "goodbye" },
      { frontText: "s'il vous plaÃ®t", backText: "please" }
    ];

    function parseCard(raw) {
      const parts = raw.split("|");
      if (parts.length < 2) return null;
      return { 
        frontText: parts[0].trim(), 
        backText: parts[1].trim() 
      };
    }

    const inputCards = rawCards.map(parseCard).filter(Boolean);
    const deck = inputCards.length ? inputCards : defaultCards;

    // --- 2. Storage & Queue Management ---
    const STORAGE_PREFIX = "fr-flash-v4:"; 

    function getStorageKey(activeDeck) {
      const signature = activeDeck.map(c => c.frontText).join("");
      let hash = 0;
      for (let i = 0; i < signature.length; i++) {
        hash = ((hash << 5) - hash) + signature.charCodeAt(i);
        hash |= 0;
      }
      return `${STORAGE_PREFIX}${hash}`;
    }

    const storageKey = getStorageKey(deck);

    function loadQueue() {
      const stored = localStorage.getItem(storageKey);
      if (!stored) return [...deck];
      try {
        const parsed = JSON.parse(stored);
        if (Array.isArray(parsed.queue) && parsed.queue.length > 0) {
          return parsed.queue;
        }
      } catch (e) { console.error("Save file corrupted"); }
      return [...deck];
    }

    const queue = loadQueue();

    // --- 3. UI Rendering ---
    function getNextCard() {
      return queue[0];
    }

    function renderQueueList() {
      queueList.innerHTML = "";
      queueCountEl.textContent = `(${queue.length})`;
      
      if(queue.length === 0) {
        queueList.innerHTML = "<div>No cards left!</div>";
        return;
      }

      queue.slice(0, 5).forEach((card, index) => {
        const line = document.createElement("div");
        line.textContent = `${index + 1}. ${card.frontText}`;
        queueList.appendChild(line);
      });
      
      if(queue.length > 5) {
        const more = document.createElement("div");
        more.textContent = `...and ${queue.length - 5} more`;
        more.style.fontStyle = "italic";
        queueList.appendChild(more);
      }
    }

    function hideTextStrictly() {
      // Remove visibility class immediately
      frontTextEl.classList.remove("is-visible");
      flashcard.classList.remove("is-flipped");
    }

    function renderCurrent() {
      const card = getNextCard();
      
      if (!card) {
        frontTextEl.textContent = "ðŸŽ‰";
        frontTextEl.classList.add("is-visible"); // Reveal the trophy
        backTextEl.textContent = "All done!";
        progressEl.textContent = "0 Cards remaining";
        ratingButtons.forEach(b => b.disabled = true);
        speakButton.style.display = "none";
        renderQueueList();
        return;
      }
      
      // 1. Ensure hidden BEFORE changing text
      hideTextStrictly();
      
      // 2. Change text (user only sees blur updating)
      speakButton.style.display = "flex";
      frontTextEl.textContent = card.frontText;
      backTextEl.textContent = card.backText;
      progressEl.textContent = `${queue.length} Card${queue.length === 1 ? '' : 's'} remaining`;
      
      ratingButtons.forEach(b => b.disabled = false);
      renderQueueList();
    }

    // --- 4. Interactions ---

    function handleRating(rating) {
      const currentCard = queue.shift(); 
      if (!currentCard) return;

      if (rating === "again") {
        queue.splice(2, 0, currentCard);
      } else if (rating === "hard") {
        queue.splice(6, 0, currentCard);
      } else if (rating === "good") {
        queue.push(currentCard);
      } 
      
      localStorage.setItem(storageKey, JSON.stringify({ queue }));
      
      flashcard.classList.remove("is-flipped");
      setTimeout(() => {
        renderCurrent();
      }, 250); 
    }

    flashcard.addEventListener("click", (e) => {
      // Don't flip if clicking speaker or the text 
      if (e.target.closest('.speak-button')) return;
      if (e.target.closest('#front-text')) return; 
      
      flashcard.classList.toggle("is-flipped");
    });

    frontTextEl.addEventListener("click", (e) => {
      e.stopPropagation();
      frontTextEl.classList.toggle("is-visible");
    });

    function setupSpeech() {
      const voices = window.speechSynthesis.getVoices();
      preferredVoice = voices.find(v => v.lang.includes("fr")) || null;
    }
    window.speechSynthesis.onvoiceschanged = setupSpeech;
    setupSpeech(); 

    speakButton.addEventListener("click", (e) => {
      e.stopPropagation();
      const text = frontTextEl.textContent;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = DEFAULT_TTS_LANG;
      if (preferredVoice) u.voice = preferredVoice;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    });

    ratingButtons.forEach(btn => {
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        handleRating(btn.dataset.rating);
      });
    });

    renderCurrent();
  </script>
</body>
</html>
