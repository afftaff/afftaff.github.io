<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Game Boy Snapshot Translator</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0b1120;
      --panel: #0f172a;
      --accent: #22c55e;
      --accent-hover: #16a34a;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --border: #1f2937;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Poppins', system-ui, sans-serif;
      background: radial-gradient(circle at 15% 20%, rgba(34,197,94,0.10), transparent 35%),
                  radial-gradient(circle at 85% 0%, rgba(56,189,248,0.12), transparent 30%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      padding: 22px 28px;
      border-bottom: 1px solid var(--border);
      background: rgba(15,23,42,0.85);
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
      z-index: 5;
    }
    header h1 { margin: 0 0 6px; font-size: 24px; }
    header p { margin: 0; color: var(--muted); }

    main {
      max-width: 1200px;
      margin: 0 auto;
      padding: 26px;
      display: grid;
      grid-template-columns: 1.35fr 0.9fr;
      gap: 20px;
    }
    @media (max-width: 1024px) {
      main { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
    }

    .emu-toolbar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 12px;
      align-items: center;
    }

    button, .file-btn {
      border: none;
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      font-family: inherit;
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      color: #0b1120;
    }

    button.secondary {
      background: transparent;
      color: var(--text);
      border: 1px solid var(--border);
    }

    button.ghost {
      background: transparent;
      color: var(--muted);
      border: 1px dashed var(--border);
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .file-btn {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      position: relative;
      overflow: hidden;
    }
    .file-btn input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
    }

    #emu-container {
      position: relative;
      background: #0a0f1f;
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 14px;
      min-height: 420px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    #game {
      width: 100%;
      height: 100%;
      min-height: 360px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #game canvas {
      width: 100% !important;
      height: auto !important;
      max-height: 520px;
      image-rendering: pixelated;
      border-radius: 8px;
      background: #000;
    }

    .status-line {
      margin-top: 12px;
      font-size: 14px;
      color: var(--muted);
    }

    .info-list {
      margin: 12px 0 0;
      padding-left: 18px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-bottom: 12px;
    }
    .field label { font-size: 13px; color: var(--muted); }
    .field input {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      background: #0b1224;
      color: var(--text);
      font-size: 14px;
      outline: none;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(56,189,248,0.12);
      border-radius: 999px;
      border: 1px solid rgba(56,189,248,0.3);
      color: var(--text);
      font-weight: 600;
      font-size: 12px;
    }

    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(11, 17, 32, 0.92);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 4;
    }
    .overlay.hidden { display: none; }

    .flashcard {
      width: min(640px, 100%);
      background: #0f172a;
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 22px;
      box-shadow: 0 24px 50px rgba(0,0,0,0.45);
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .flashcard h2 {
      margin: 0;
      font-size: 22px;
      letter-spacing: -0.01em;
    }

    .flashcard .translation {
      font-size: 18px;
      color: var(--accent);
      font-weight: 700;
    }

    .flashcard .breakdown {
      background: rgba(15,23,42,0.8);
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 12px;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.5;
    }

    .flashcard .breakdown.hidden { display: none; }

    .flashcard-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: space-between;
      align-items: center;
    }

    .grade-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .grade-row button { min-width: 92px; }
    .grade-row button.secondary { background: rgba(15,23,42,0.6); }

    .queue-info { font-size: 13px; color: var(--muted); }

    .hidden { display: none; }
  </style>
</head>
<body>
  <header>
    <h1>Game Boy Snapshot Translator</h1>
    <p>Load a ROM, grab a screenshot, and turn French game text into spaced-repetition flashcards.</p>
  </header>

  <main>
    <section class="panel">
      <div class="emu-toolbar">
        <label class="file-btn">Load ROM<input type="file" id="romInput" accept=".gb,.gbc,.zip" /></label>
        <button id="snapshotBtn" class="secondary">Snapshot → Gemini</button>
        <button id="reviewBtn" class="ghost">Review deck</button>
      </div>

      <div id="emu-container">
        <div id="game">
          <p style="color: var(--muted);">Load a Game Boy ROM to start playing.</p>
        </div>
        <div id="flashcardOverlay" class="overlay hidden">
          <div class="flashcard">
            <div class="pill" id="deckPill">0 cards</div>
            <h2 id="cardPrompt">Waiting for snapshot…</h2>
            <div id="cardTranslation" class="translation hidden"></div>
            <div id="cardBreakdown" class="breakdown hidden"></div>
            <div class="flashcard-actions">
              <div class="grade-row hidden" id="gradeRow">
                <button data-grade="again" class="secondary">Again</button>
                <button data-grade="hard" class="secondary">Hard</button>
                <button data-grade="good">Good</button>
                <button data-grade="easy">Easy</button>
              </div>
              <button id="revealBtn" class="secondary">Reveal answer</button>
            </div>
            <div class="queue-info" id="queueInfo"></div>
          </div>
        </div>
      </div>

      <div class="emu-toolbar" style="margin-top: 14px;">
        <button id="exportSave" class="secondary">Export save</button>
        <label class="file-btn" style="background: transparent; border: 1px solid var(--border); color: var(--text);">
          Import save
          <input type="file" id="importSave" accept=".sav,.srm,.bin" />
        </label>
        <button id="clearSave" class="ghost">Clear save</button>
      </div>
      <div class="status-line" id="statusLine">Ready.</div>
    </section>

    <aside class="panel">
      <div class="field">
        <label for="geminiKey">Gemini API key</label>
        <input id="geminiKey" type="password" placeholder="Paste your Google AI Studio API key" />
        <button id="saveKey">Save key</button>
      </div>

      <div class="field">
        <span class="pill" id="duePill">0 due / 0 total</span>
      </div>

      <p style="color: var(--muted); margin-top: 10px;">How it works:</p>
      <ul class="info-list">
        <li>Load a ROM and start playing. EmulatorJS will keep your save in the browser automatically.</li>
        <li>Press “Snapshot → Gemini” to capture the screen and create flashcards from the text.</li>
        <li>Flashcards appear over the emulator and the game pauses until you finish the review.</li>
        <li>Use export/import to back up or replace the current save file.</li>
      </ul>

      <div class="status-line" style="margin-top: 16px;">
        Expected Gemini format:
        <pre style="white-space: pre-wrap; color: var(--muted);">[Un ARTIKODIN sauvage apparaît ! | A wild ARCTICUNO appears!]
( Un | a | masculine singular )
( ARTIKODIN | ARCTICUNO | masculine noun )
( sauvage | wild | adjective )
( apparaît | appears | 3rd person singular present of apparaître )</pre>
      </div>
    </aside>
  </main>

  <script src="../dir/geminiApi.js"></script>
  <script>
    const SYSTEM_INSTRUCTION = `Take text from image, translate and return like this:\n\n[Le professeur est arrivé tôt ce matin | The professor arrived early this morning.]\n( Le | the | masc ) \n( professeur | teacher | masc ) \n( est | is / has | N/A ) \n( arrivé | arrived | masc ) \n( tôt | early | N/A ) \n( ce | this | masculine singular ) \n( matin | morning | masculine noun )`;

    const dom = {
      romInput: document.getElementById('romInput'),
      snapshotBtn: document.getElementById('snapshotBtn'),
      reviewBtn: document.getElementById('reviewBtn'),
      overlay: document.getElementById('flashcardOverlay'),
      prompt: document.getElementById('cardPrompt'),
      translation: document.getElementById('cardTranslation'),
      breakdown: document.getElementById('cardBreakdown'),
      revealBtn: document.getElementById('revealBtn'),
      gradeRow: document.getElementById('gradeRow'),
      queueInfo: document.getElementById('queueInfo'),
      deckPill: document.getElementById('deckPill'),
      duePill: document.getElementById('duePill'),
      status: document.getElementById('statusLine'),
      exportSave: document.getElementById('exportSave'),
      importSave: document.getElementById('importSave'),
      clearSave: document.getElementById('clearSave'),
      geminiKey: document.getElementById('geminiKey'),
      saveKey: document.getElementById('saveKey')
    };

    const STORAGE_DECK = 'gbFlashcards';
    const STORAGE_SRS = 'gbFlashcardsSrs';
    const DECK_NAME = 'gb-snapshot-deck';

    let deck = [];
    let srsState = {};
    let reviewQueue = [];
    let reviewIndex = 0;

    function setStatus(message) {
      dom.status.textContent = message;
    }

    function loadState() {
      deck = JSON.parse(localStorage.getItem(STORAGE_DECK) || '[]');
      srsState = JSON.parse(localStorage.getItem(STORAGE_SRS) || '{}');
      updateDeckStats();
    }

    function persistDeck() {
      localStorage.setItem(STORAGE_DECK, JSON.stringify(deck));
      updateDeckStats();
    }

    function persistSrs() {
      localStorage.setItem(STORAGE_SRS, JSON.stringify(srsState));
      updateDeckStats();
    }

    function getCardState(id) {
      return (srsState[DECK_NAME] || {})[id] || null;
    }

    function scheduleCard(id, grade) {
      const now = Date.now();
      const deckState = srsState[DECK_NAME] || {};
      const current = deckState[id] || { ease: 2.5, interval: 0, repetitions: 0, lapses: 0, due: now };
      const qualityMap = { again: 1, hard: 2, good: 3, easy: 4 };
      const quality = qualityMap[grade] || 3;
      const state = { ...current };

      if (quality < 2) {
        state.repetitions = 0;
        state.interval = quality === 1 ? 0.007 : 1;
        state.ease = Math.max(1.3, (state.ease ?? 2.5) - 0.2);
        state.lapses = (state.lapses ?? 0) + 1;
      } else {
        const ease = state.ease ?? 2.5;
        let newEase = ease + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        newEase = Math.max(1.3, newEase);
        state.ease = newEase;
        if (state.repetitions === 0) {
          state.interval = grade === 'easy' ? 3 : 1;
        } else if (state.repetitions === 1) {
          state.interval = grade === 'easy' ? 8 : 6;
        } else {
          state.interval = Math.round(state.interval * newEase);
        }
        if (grade === 'hard') state.interval = Math.max(1, Math.round(state.interval * 0.6));
        if (grade === 'easy') state.interval = Math.round(state.interval * 1.3);
        state.repetitions += 1;
      }

      const intervalMs = state.interval * 24 * 60 * 60 * 1000;
      state.due = now + Math.max(intervalMs, 10 * 60 * 1000);
      state.lastGrade = grade;
      srsState[DECK_NAME] = { ...deckState, [id]: state };
      return state;
    }

    function getReviewQueue(cards) {
      const now = Date.now();
      const due = [];
      const fresh = [];
      cards.forEach((card) => {
        const state = getCardState(card.id);
        if (!state) { fresh.push({ id: card.id, card, due: now }); }
        else if (state.due <= now) { due.push({ id: card.id, card, due: state.due }); }
      });
      due.sort((a, b) => a.due - b.due);
      fresh.sort((a, b) => a.card.term.localeCompare(b.card.term));
      return [...due, ...fresh];
    }

    function formatDueDate(timestamp) {
      const delta = timestamp - Date.now();
      if (delta <= 0) return 'Available now';
      const minutes = Math.max(1, Math.round(delta / 60000));
      if (minutes < 60) return `${minutes} min`;
      const hours = minutes / 60;
      if (hours < 24) return `${hours.toFixed(hours < 10 ? 1 : 0)} hr`;
      const days = hours / 24;
      if (days < 7) return `${days.toFixed(days < 3 ? 1 : 0)} days`;
      const weeks = days / 7;
      return `${weeks.toFixed(weeks < 3 ? 1 : 0)} weeks`;
    }

    function updateDeckStats() {
      dom.deckPill.textContent = `${deck.length} cards`;
      if (!deck.length) {
        dom.duePill.textContent = '0 due / 0 total';
        return;
      }
      const now = Date.now();
      const stats = deck.reduce((acc, card) => {
        const st = getCardState(card.id);
        if (!st) acc.fresh += 1;
        else if (st.due <= now) acc.due += 1;
        else acc.waiting += 1;
        return acc;
      }, { due: 0, waiting: 0, fresh: 0 });
      const nextDue = deck
        .map((card) => getCardState(card.id)?.due)
        .filter(Boolean)
        .sort((a, b) => a - b)[0];
      dom.duePill.textContent = `${stats.due + stats.fresh} due / ${deck.length} total${nextDue ? ` • next ${formatDueDate(nextDue)}` : ''}`;
    }

    function openOverlay() {
      dom.overlay.classList.remove('hidden');
      pauseEmulator();
    }

    function closeOverlay() {
      dom.overlay.classList.add('hidden');
      resumeEmulator();
    }

    function renderCard(entry) {
      dom.prompt.textContent = entry.card.term;
      dom.translation.textContent = entry.card.translation;
      dom.translation.classList.add('hidden');
      dom.breakdown.innerHTML = entry.card.breakdown.map(line => `<div>${line}</div>`).join('');
      dom.breakdown.classList.add('hidden');
      dom.revealBtn.classList.remove('hidden');
      dom.gradeRow.classList.add('hidden');
      updateQueueInfo();
    }

    function updateQueueInfo() {
      dom.queueInfo.textContent = `${reviewQueue.length} card(s) left in this session.`;
    }

    function startReviewSession() {
      if (!deck.length) {
        setStatus('Create a snapshot first to build a deck.');
        return;
      }
      const queue = getReviewQueue(deck);
      if (!queue.length) {
        setStatus('No cards are due yet.');
        return;
      }
      reviewQueue = queue;
      reviewIndex = 0;
      renderCard(reviewQueue[reviewIndex]);
      openOverlay();
    }

    function completeReview() {
      dom.prompt.textContent = 'Deck completed!';
      dom.translation.textContent = 'You can resume the game.';
      dom.translation.classList.remove('hidden');
      dom.breakdown.classList.add('hidden');
      dom.revealBtn.textContent = 'Resume game';
      dom.revealBtn.classList.remove('hidden');
      dom.gradeRow.classList.add('hidden');
      dom.queueInfo.textContent = '';
    }

    function gradeCurrentCard(grade) {
      const entry = reviewQueue[reviewIndex];
      scheduleCard(entry.id, grade);
      reviewQueue.splice(reviewIndex, 1);
      persistSrs();
      if (!reviewQueue.length) {
        completeReview();
        return;
      }
      reviewIndex = 0;
      renderCard(reviewQueue[reviewIndex]);
    }

    function parseGeminiResponse(text) {
      const lines = text.split(/\n+/).map(line => line.trim()).filter(Boolean);
      const cards = [];
      let current = null;
      lines.forEach((line) => {
        const bracketMatch = line.match(/\[(.*)\]/);
        if (bracketMatch) {
          const payload = bracketMatch[1];
          const parts = payload.split('|').map(p => p.trim());
          const term = parts[0] || 'Unknown';
          const translation = parts[1] || '';
          current = {
            id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
            term,
            translation,
            breakdown: []
          };
          cards.push(current);
          return;
        }
        const breakdownMatch = line.match(/^\((.*)\)$/);
        if (breakdownMatch && current) {
          current.breakdown.push(`(${breakdownMatch[1]})`);
        }
      });
      if (!cards.length) {
        throw new Error('Could not parse Gemini response.');
      }
      return cards;
    }

    async function snapshotAndTranslate() {
      if (!window.geminiApi) {
        setStatus('Gemini API helper not loaded.');
        return;
      }
      const apiKey = window.geminiApi.loadGeminiKey(dom.geminiKey);
      if (!apiKey) {
        setStatus('Add your Gemini API key first.');
        return;
      }
      const canvas = document.querySelector('#game canvas');
      if (!canvas) {
        setStatus('Emulator is not ready yet.');
        return;
      }
      dom.snapshotBtn.disabled = true;
      setStatus('Capturing snapshot and sending to Gemini...');
      try {
        const dataUrl = canvas.toDataURL('image/png');
        const response = await window.geminiApi.callGemini(
          SYSTEM_INSTRUCTION,
          '',
          'gemini-flash-latest',
          { images: [dataUrl] }
        );
        const newCards = parseGeminiResponse(response);
        deck = [...deck, ...newCards];
        persistDeck();
        setStatus(`Added ${newCards.length} card(s) to the deck.`);
        startReviewSession();
      } catch (error) {
        console.error(error);
        setStatus(error.message || 'Snapshot failed.');
      } finally {
        dom.snapshotBtn.disabled = false;
      }
    }

    function pauseEmulator() {
      if (window.EJS_emulator?.gameManager?.pause) {
        window.EJS_emulator.gameManager.pause();
      } else if (window.EJS_emulator?.pause) {
        window.EJS_emulator.pause();
      }
    }

    function resumeEmulator() {
      if (window.EJS_emulator?.gameManager?.resume) {
        window.EJS_emulator.gameManager.resume();
      } else if (window.EJS_emulator?.resume) {
        window.EJS_emulator.resume();
      }
    }

    function loadEmulatorFromFile(file) {
      if (!file) return;
      const gameUrl = URL.createObjectURL(file);
      window.EJS_player = '#game';
      window.EJS_gameUrl = gameUrl;
      window.EJS_core = 'gb';
      window.EJS_gameName = file.name.replace(/\.[^/.]+$/, '');
      window.EJS_startOnLoaded = true;
      window.EJS_pathtodata = 'https://cdn.emulatorjs.org/latest/data/';

      const existing = document.getElementById('emu-loader');
      if (existing) {
        setStatus('Emulator already running. Refresh the page to load a new ROM.');
        return;
      }
      const script = document.createElement('script');
      script.id = 'emu-loader';
      script.src = 'https://cdn.emulatorjs.org/loader.js';
      script.onload = () => setStatus('Emulator loaded.');
      script.onerror = () => setStatus('Failed to load emulator loader script. Check your connection.');
      document.body.appendChild(script);
    }

    async function exportSaveFile() {
      const manager = window.EJS_emulator?.gameManager?.saveManager || window.EJS_emulator?.saveManager;
      if (manager?.download) {
        manager.download();
        setStatus('Save file downloaded.');
        return;
      }
      if (window.EJS_emulator?.gameManager?.downloadSave) {
        window.EJS_emulator.gameManager.downloadSave();
        setStatus('Save file downloaded.');
        return;
      }
      setStatus('Save export not supported by this emulator build.');
    }

    async function importSaveFile(file) {
      if (!file) return;
      const buffer = await file.arrayBuffer();
      const data = new Uint8Array(buffer);
      const manager = window.EJS_emulator?.gameManager?.saveManager || window.EJS_emulator?.saveManager;
      if (manager?.importSave) {
        manager.importSave(data, file.name);
        setStatus('Save file imported. Restart the game if needed.');
        return;
      }
      if (manager?.load) {
        manager.load(data, file.name);
        setStatus('Save file loaded.');
        return;
      }
      setStatus('Save import not supported by this emulator build.');
    }

    function clearSaveFile() {
      const manager = window.EJS_emulator?.gameManager?.saveManager || window.EJS_emulator?.saveManager;
      if (manager?.clear) {
        manager.clear();
        setStatus('Save file cleared.');
        return;
      }
      setStatus('Save clear not supported by this emulator build.');
    }

    dom.romInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      loadEmulatorFromFile(file);
    });

    dom.snapshotBtn.addEventListener('click', snapshotAndTranslate);
    dom.reviewBtn.addEventListener('click', startReviewSession);

    dom.revealBtn.addEventListener('click', () => {
      if (dom.revealBtn.textContent === 'Resume game') {
        closeOverlay();
        dom.revealBtn.textContent = 'Reveal answer';
        return;
      }
      dom.translation.classList.remove('hidden');
      dom.breakdown.classList.remove('hidden');
      dom.gradeRow.classList.remove('hidden');
      dom.revealBtn.classList.add('hidden');
    });

    dom.gradeRow.querySelectorAll('button').forEach((btn) => {
      btn.addEventListener('click', () => gradeCurrentCard(btn.dataset.grade));
    });

    dom.exportSave.addEventListener('click', exportSaveFile);
    dom.importSave.addEventListener('change', (event) => importSaveFile(event.target.files[0]));
    dom.clearSave.addEventListener('click', clearSaveFile);

    dom.saveKey.addEventListener('click', () => {
      window.geminiApi?.saveGeminiKey(dom.geminiKey.value);
      setStatus('Gemini API key saved.');
    });

    loadState();
    if (window.geminiApi) {
      window.geminiApi.loadGeminiKey(dom.geminiKey);
    }
  </script>
</body>
</html>
