<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>French Verb Guesser</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: light dark;
    }

    body {
      margin: 0;
      padding: 0;
      background: #0f172a;
      color: #e5e7eb;
    }

    .app {
      max-width: 980px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.1rem;
      margin: 1.8rem 0 0.4rem;
    }

    p {
      margin: 0.2rem 0 0.4rem;
      color: #cbd5f5;
      font-size: 0.9rem;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      min-height: 120px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      resize: vertical;
      font-family: inherit;
      font-size: 0.95rem;
    }

    textarea[readonly] {
      opacity: 0.8;
    }

    label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.3rem;
    }

    .inline-label {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 0.6rem;
      font-size: 0.9rem;
    }

    .inline-label input[type="checkbox"] {
      margin-right: 4px;
    }

    input[type="password"],
    input[type="text"] {
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-family: inherit;
      font-size: 0.9rem;
      min-width: 260px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 7px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #10b981;
      color: #020617;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .button-row {
      margin-top: 0.7rem;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .status {
      margin-top: 0.8rem;
      min-height: 1.2rem;
      font-size: 0.85rem;
      color: #a5b4fc;
      white-space: pre-line;
    }

    .card-shell {
      margin-top: 1rem;
      border-radius: 12px;
      border: 1px solid #1f2937;
      background: radial-gradient(circle at top left, #0f172a, #020617 52%);
      padding: 16px 14px;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card-question {
      font-size: 1rem;
      line-height: 1.4;
    }

    .card-question strong {
      font-weight: 600;
    }

    select {
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-family: inherit;
      font-size: 0.9rem;
      max-width: 100%;
    }

    select.select-correct {
      border-color: #16a34a;
      background: linear-gradient(120deg, #022c22, #0b3b2c);
      color: #bbf7d0;
    }

    select.select-wrong {
      border-color: #b91c1c;
      background: linear-gradient(120deg, #2c0a0a, #3f1a1a);
      color: #fecaca;
    }

    .flashcard-footer {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 0.6rem;
    }

    .srs-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .srs-buttons button {
      flex: 0 0 auto;
      font-size: 0.85rem;
      padding-inline: 12px;
    }

    .srs-buttons button.again {
      background: #b91c1c;
      color: #f9fafb;
    }

    .srs-buttons button.medium {
      background: #4b5563;
      color: #f9fafb;
    }

    .srs-buttons button.easy {
      background: #22c55e;
      color: #052e16;
    }

    .feedback {
      font-size: 0.9rem;
      min-height: 1.1rem;
    }

    .feedback.ok {
      color: #6ee7b7;
    }

    .feedback.bad {
      color: #fecaca;
    }

    .meta {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 0.4rem;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-right: 6px;
    }

    .conjugation-details {
      border: 1px dashed #1f2937;
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 8px;
      background: rgba(59, 130, 246, 0.04);
      color: #bfdbfe;
      font-size: 0.9rem;
    }

    .definition-box {
      border: 1px solid #1f2937;
      border-radius: 10px;
      padding: 10px 12px;
      margin-top: 10px;
      background: #0b1224;
      color: #e5e7eb;
      line-height: 1.45;
    }

    .definition-box ul {
      margin: 6px 0 0;
      padding-left: 18px;
    }

    .definition-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
    }

    .verb-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      margin-right: 8px;
    }

    @media (min-width: 860px) {
      .layout-two-column {
        display: grid;
        grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
        gap: 20px;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>French Verb Guesser</h1>
    <p>Paste French text, optionally clean it with Gemini, then practice guessing verb forms from dropdowns.</p>

    <section>
      <h2>API key</h2>
      <label for="apiKey">Gemini API key</label>
      <div class="button-row">
        <input id="apiKey" type="password" autocomplete="off" placeholder="Your Gemini API key" />
        <button id="saveKey" class="secondary" type="button">Save key locally</button>
      </div>
      <p class="meta">Stored in your browser’s localStorage only.</p>
    </section>

    <div class="layout-two-column">
      <section>
        <h2>1. Input text</h2>
        <label for="sourceText">Raw French sentences (one per line, or a paragraph without punctuation)</label>
        <textarea id="sourceText" placeholder="Eg: il faut que je parte demain matin&#10;je voudrais apprendre le français rapidement"></textarea>

        <label class="inline-label">
          <input type="checkbox" id="useCleaning" checked />
          Use Gemini to clean / punctuate first (uses <code>cleaningInstruction</code>)
        </label>

        <div class="button-row">
          <button id="buildDeck" type="button">Build verb deck (max 10)</button>
        </div>

        <div id="status" class="status"></div>
      </section>

      <section>
        <h2>2. Cleaned sentences</h2>
        <p>This shows the result of the cleaning step before flashcards are built.</p>
        <textarea id="cleanedText" readonly placeholder="Cleaned sentences will appear here."></textarea>
      </section>
    </div>

    <section>
      <h2>3. Flashcards</h2>
      <p>Each flashcard hides every recognised verb and offers a dropdown of that verb’s conjugations.</p>

      <div id="cardShell" class="card-shell">
        <div id="cardContent" class="card-question">
          No cards yet. Build a deck to begin.
        </div>

        <div class="flashcard-footer">
          <div class="button-row">
            <button id="checkBtn" type="button" disabled>Check answers</button>
            <button id="nextBtn" type="button" class="secondary" disabled>Next card</button>
            <button id="revealBtn" type="button" class="secondary" disabled>Reveal original</button>
          </div>
          <div class="srs-buttons">
            <button id="againBtn" type="button" class="again" disabled>Again</button>
            <button id="mediumBtn" type="button" class="medium" disabled>Medium</button>
            <button id="easyBtn" type="button" class="easy" disabled>Easy</button>
          </div>
          <div id="feedback" class="feedback"></div>
          <div id="explanation" class="explanation"></div>
          <div id="conjugationInfo" class="conjugation-details" style="display:none;"></div>
          <div id="cardMeta" class="meta"></div>
          <div class="definition-actions">
            <button id="definitionBtn" class="secondary" type="button" disabled>Get definition</button>
            <span id="definitionStatus" class="meta"></span>
          </div>
          <div id="definitionResult" class="definition-box" style="display:none;"></div>
        </div>
      </div>
    </section>
  </div>

  <script>
    const cleaningInstruction =
      "I'll give you some text without punctuation and can you fix them in to sentences please. Do not say anything, just return the fixed text.";

    function loadKey() {
      const input = document.getElementById('apiKey');
      const stored = localStorage.getItem('geminiApiKey');

      if (input && input.value.trim()) {
        return input.value.trim();
      }

      if (stored) {
        if (input && !input.value) {
          input.value = stored;
        }
        return stored;
      }

      return null;
    }

    function saveKey() {
      const input = document.getElementById('apiKey');
      if (!input) return;
      const value = input.value.trim();
      if (value) {
        localStorage.setItem('geminiApiKey', value);
      }
    }

    async function callGemini(systemInstruction, userContent) {
      const key = loadKey();
      if (!key) throw new Error('Missing API key');

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=${key}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            systemInstruction: { parts: [{ text: systemInstruction }] },
            contents: [{ parts: [{ text: userContent }] }]
          })
        }
      );

      const raw = await response.text();
      let data;
      try {
        data = JSON.parse(raw);
      } catch (e) {
        data = null;
      }

      if (!response.ok || data?.error) {
        const err = new Error(
          data?.error?.message || `Request failed (${response.status})`
        );
        err.raw = raw;
        throw err;
      }

      const botText = data?.candidates?.[0]?.content?.parts?.[0]?.text;
      if (!botText) throw new Error('No content returned.');
      return botText;
    }

    const FLASHCARD_CACHE_KEY = 'verbGuesserFlashcardCache';
    const STATE_CACHE_KEY = 'verbGuesserState';
    let flashcardCache = {};

    function loadFlashcardCache() {
      try {
        const raw = localStorage.getItem(FLASHCARD_CACHE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (e) {
        console.warn('Could not load flashcard cache', e);
        return {};
      }
    }

    function saveFlashcardCache() {
      try {
        localStorage.setItem(FLASHCARD_CACHE_KEY, JSON.stringify(flashcardCache));
      } catch (e) {
        console.warn('Could not save flashcard cache', e);
      }
    }

    const verbToOptions = new Map();
    const conjugationToVerb = new Map();
    const conjugationMeta = new Map();
    let deck = [];
    let queue = [];
    let currentNode = null;
    let hasChecked = false;
    let selectedVerbForDefinition = '';

    function saveAppState() {
      try {
        const sourceEl = document.getElementById('sourceText');
        const cleanedEl = document.getElementById('cleanedText');
        const useCleaningEl = document.getElementById('useCleaning');

        const state = {
          rawText: sourceEl?.value || '',
          cleanedText: cleanedEl?.value || '',
          useCleaning: !!useCleaningEl?.checked,
          deck,
          queueIds: queue.map(n => n.id),
          currentId: currentNode ? currentNode.id : null,
          hasChecked
        };

        localStorage.setItem(STATE_CACHE_KEY, JSON.stringify(state));
      } catch (e) {
        console.warn('Could not save state', e);
      }
    }

    function restoreAppState() {
      try {
        const raw = localStorage.getItem(STATE_CACHE_KEY);
        if (!raw) return;
        const state = JSON.parse(raw);
        if (!state || typeof state !== 'object') return;

        const sourceEl = document.getElementById('sourceText');
        const cleanedEl = document.getElementById('cleanedText');
        const useCleaningEl = document.getElementById('useCleaning');

        if (sourceEl && state.rawText) sourceEl.value = state.rawText;
        if (cleanedEl && state.cleanedText) cleanedEl.value = state.cleanedText;
        if (useCleaningEl && typeof state.useCleaning === 'boolean') {
          useCleaningEl.checked = state.useCleaning;
        }

        if (Array.isArray(state.deck)) deck = state.deck;
        if (Array.isArray(state.queueIds)) {
          queue = state.queueIds
            .map(id => ({ entry: deck[id], id }))
            .filter(node => !!node.entry);
        }

        if (state.currentId !== null && state.currentId !== undefined) {
          const entry = deck[state.currentId];
          if (entry) {
            currentNode = { entry, id: state.currentId };
          }
        }

        hasChecked = !!state.hasChecked;

        if (deck.length) {
          renderCurrentCard();
          setStatus(`Restored deck with ${deck.length} sentences.`);
        }
      } catch (e) {
        console.warn('Could not restore state', e);
      }
    }

    function setStatus(text) {
      const el = document.getElementById('status');
      if (el) el.textContent = text || '';
    }

    function setFeedback(text, ok) {
      const el = document.getElementById('feedback');
      if (!el) return;
      el.textContent = text || '';
      el.className = 'feedback' + (text ? ok ? ' ok' : ' bad' : '');
    }

    function setExplanation(text) {
      const el = document.getElementById('explanation');
      if (!el) return;
      el.textContent = text || '';
    }

    function setCardMeta(text) {
      const el = document.getElementById('cardMeta');
      if (!el) return;
      el.textContent = text || '';
    }

    function setConjugationInfo(text) {
      const el = document.getElementById('conjugationInfo');
      if (!el) return;
      if (text) {
        el.style.display = 'block';
        el.innerHTML = text;
      } else {
        el.style.display = 'none';
        el.innerHTML = '';
      }
    }

    function clearSelectStatus(select) {
      select.classList.remove('select-correct', 'select-wrong');
    }

    function updateDefinitionButton(word) {
      const btn = document.getElementById('definitionBtn');
      if (!btn) return;
      const targetWord = (word || '').trim();
      selectedVerbForDefinition = targetWord;
      btn.textContent = targetWord
        ? `Get definition for: ${targetWord}`
        : 'Get definition';
      btn.disabled = !targetWord;
    }

    function getMetaForSelection(select) {
      const verb = select?.dataset?.verb || '';
      const value = select?.value || '';
      if (!verb || !value) return null;
      return conjugationMeta.get(`${verb}:::${value.toLowerCase()}`) || null;
    }

    function showSelectionDetails(select) {
      const meta = getMetaForSelection(select);
      if (!meta) {
        setConjugationInfo('');
        return;
      }
      const verb = select.dataset.verb;
      const selectedForm = (select.value || '').trim() || verb;
      setConjugationInfo(
        `<strong>${selectedForm}</strong><br>${meta.label}<br><em>Example: ${meta.example}</em><br>lemma: ${verb}`
      );
    }

    function setDefinitionStatus(text) {
      const el = document.getElementById('definitionStatus');
      if (el) el.textContent = text || '';
    }

    function setDefinitionResult(definitionsHtml) {
      const el = document.getElementById('definitionResult');
      if (!el) return;
      if (!definitionsHtml) {
        el.style.display = 'none';
        el.innerHTML = '';
        return;
      }
      el.style.display = 'block';
      el.innerHTML = definitionsHtml;
    }

    function renderNoCards(message) {
      const cardContent = document.getElementById('cardContent');
      if (cardContent) {
        cardContent.textContent = message || 'No cards to show.';
      }

      const checkBtn = document.getElementById('checkBtn');
      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');
      const nextBtn = document.getElementById('nextBtn');
      const revealBtn = document.getElementById('revealBtn');

        [checkBtn, againBtn, mediumBtn, easyBtn, nextBtn, revealBtn].forEach(btn => {
          if (btn) btn.disabled = true;
        });

        setConjugationInfo('');
        setDefinitionStatus('');
        setDefinitionResult('');
        updateDefinitionButton('');
      }

    function normaliseWord(word) {
      return word.toLowerCase().replace(/^['"«»“”‘’\(\[]+/, '').replace(/['"«»“”’”\)\]]+$/, '');
    }

    function splitSentences(text) {
      return text
        .split(/[\.\r?\n]+/)
        .map(s => s.trim())
        .filter(Boolean);
    }

    const ENGLISH_SAMPLE_VERB = 'learn';

    function capitalise(str) {
      return str ? str.charAt(0).toUpperCase() + str.slice(1) : '';
    }

    function personToSubject(person) {
      const key = (person || '').toLowerCase();
      if (key.includes('first person singular')) return 'I';
      if (key.includes('second person singular')) return 'you';
      if (key.includes('third person singular')) return 'he/she/it';
      if (key.includes('first person plural')) return 'we';
      if (key.includes('second person plural')) return 'you (pl.)';
      if (key.includes('third person plural')) return 'they';
      return '';
    }

    function buildEnglishExample(parts) {
      const lowerParts = parts.map(p => p.toLowerCase());
      const person = lowerParts.find(p => p.includes('person')) || '';
      const tense = lowerParts.find(p =>
        ['present', 'imperfect', 'future', 'conditional', 'subjunctive', 'imperative', 'past participle', 'present participle', 'gerund', 'past historic', 'compound verb'].includes(p)
      ) || '';

      const subject = personToSubject(person);
      const base = ENGLISH_SAMPLE_VERB;

      function subjectPrefix() {
        return subject ? `${subject} ` : '';
      }

      switch (tense) {
        case 'present':
          return `${subjectPrefix()}${subject === 'he/she/it' ? `${base}s` : base}`;
        case 'imperfect':
          return `${subjectPrefix()}was ${base}ing`;
        case 'future':
          return `${subjectPrefix()}will ${base}`;
        case 'conditional':
          return `${subjectPrefix()}would ${base}`;
        case 'subjunctive':
          return `${subjectPrefix()}${base} (subjunctive mood)`;
        case 'imperative':
          return `Learn! (command)`;
        case 'past participle':
          return `${subjectPrefix()}has ${base}ed`;
        case 'present participle':
          return `${subjectPrefix()}is ${base}ing`;
        case 'gerund':
          return `${base}ing`;
        case 'past historic':
          return `${subjectPrefix()}${base}ed`;
        case 'compound verb':
          return `${subjectPrefix()}has ${base} (compound)`;
        default:
          return `${subjectPrefix()}${base}`.trim();
      }
    }

    function describeConjugation(header) {
      const parts = (header || '')
        .split('|')
        .map(p => p.trim())
        .filter(Boolean);
      const label = parts.length ? parts.map(capitalise).join(' → ') : 'Verb form';
      const example = buildEnglishExample(parts);
      return { label, example };
    }

    function stripHtml(html) {
      return html
        .replace(/<[^>]*>/g, '')
        .replace(/&nbsp;/g, ' ')
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .trim();
    }

    function extractFrenchData(data) {
      const definitions = [];
      const examples = [];
      const defSeen = new Set();
      const exSeen = new Set();

      for (const value of Object.values(data)) {
        if (!Array.isArray(value)) continue;
        for (const entry of value) {
          if (entry.language && entry.language !== 'French') continue;

          const rawDefs = entry.definitions || entry.senses || [];
          for (const d of rawDefs) {
            let defHtml = '';
            if (typeof d === 'string') {
              defHtml = d;
            } else if (d && typeof d === 'object') {
              defHtml = d.definition || d.gloss || '';
            }
            const defText = stripHtml(defHtml);
            if (defText && !defSeen.has(defText)) {
              defSeen.add(defText);
              definitions.push(defText);
            }

            let exList = [];
            if (d && Array.isArray(d.examples)) exList = d.examples;
            for (const ex of exList) {
              let exHtml = '';
              if (typeof ex === 'string') exHtml = ex;
              else if (ex && typeof ex === 'object') exHtml = ex.example || ex.text || '';
              const exText = stripHtml(exHtml);
              if (exText && !exSeen.has(exText)) {
                exSeen.add(exText);
                examples.push(exText);
              }
            }
          }
        }
      }

      return { definitions, examples };
    }

    async function fetchDefinitionForWord(word) {
      const endpoint = 'https://en.wiktionary.org/api/rest_v1/page/definition/';
      const url = endpoint + encodeURIComponent(word);
      try {
        const res = await fetch(url, { headers: { accept: 'application/json' } });
        if (!res.ok) return { error: `HTTP ${res.status} ${res.statusText}` };
        const data = await res.json();
        const frenchData = extractFrenchData(data);
        if (!frenchData.definitions.length && !frenchData.examples.length) {
          return { error: 'No French definitions or examples found in Wiktionary data.' };
        }
        return frenchData;
      } catch (err) {
        return { error: String(err) };
      }
    }

    function parseCSV(text) {
      const lines = text.split(/\r?\n/).filter(Boolean);
      if (lines.length < 2) return;
      const headers = lines[0].split(',');

      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',');
        if (!cols.length) continue;
        const infinitive = cols[0]?.trim();
        if (!infinitive) continue;

        const options = new Set();
        for (let c = 0; c < cols.length; c++) {
          const cell = cols[c]?.trim();
          if (!cell) continue;

          const values = cell.split(';').map(v => v.trim()).filter(Boolean);
          for (const value of values) {
            options.add(value);
            const key = normaliseWord(value);
            if (!conjugationToVerb.has(key)) {
              conjugationToVerb.set(key, infinitive);
            }

            const header = headers[c] || '';
            const meta = describeConjugation(header);
            conjugationMeta.set(`${infinitive}:::${value.toLowerCase()}`, {
              header,
              ...meta
            });
          }
        }
        verbToOptions.set(infinitive, Array.from(options));
      }
    }

    async function loadVerbs() {
      const cached = localStorage.getItem('verbConjugationCSV');
      if (cached) {
        parseCSV(cached);
        return;
      }

      const response = await fetch('french-verb-conjugation.csv');
      if (!response.ok) throw new Error('Could not load verb list');
      const text = await response.text();
      localStorage.setItem('verbConjugationCSV', text);
      parseCSV(text);
    }

    function buildCardFromSentence(sentence) {
      const tokens = sentence.split(/(\s+)/);
      const blanks = [];

      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        if (!token.trim()) continue;
        const base = normaliseWord(token);
        const verb = conjugationToVerb.get(base);
        if (verb) {
          blanks.push({ index: i, verb, answer: token.trim() });
          tokens[i] = '__VERB__';
        }
      }

      return {
        sentence,
        tokens,
        blanks,
        original: sentence
      };
    }

    function initQueueFromDeck() {
      queue = deck.map((entry, idx) => ({ entry, id: idx }));
      currentNode = null;
      hasChecked = false;
    }

    function renderCurrentCard() {
      setFeedback('');
      setExplanation('');
      setCardMeta('');
      setConjugationInfo('');
      setDefinitionStatus('');
      setDefinitionResult('');
      updateDefinitionButton('');

      if (!currentNode || !currentNode.entry) {
        renderNoCards('No cards to show.');
        return;
      }

      const entry = currentNode.entry;
      const container = document.createElement('div');
      container.className = 'card-question';

      const questionEl = document.createElement('div');
      questionEl.style.display = 'flex';
      questionEl.style.flexWrap = 'wrap';
      questionEl.style.gap = '6px';

      let blankCounter = 0;

      entry.tokens.forEach((token, idx) => {
        if (token === '__VERB__') {
          const blank = entry.blanks.find(b => b.index === idx);
          if (!blank) {
            questionEl.appendChild(document.createTextNode('____'));
            return;
          }

          const select = document.createElement('select');
          select.id = `verb-${idx}`;
          select.dataset.correct = blank.answer;
          select.dataset.verb = blank.verb;

          const opts = Array.from(new Set(verbToOptions.get(blank.verb) || []));
          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = `Pick a form of "${blank.verb}"`;
          select.appendChild(placeholder);

          opts.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            select.appendChild(option);
          });

          clearSelectStatus(select);
          select.addEventListener('change', () => {
            clearSelectStatus(select);
            showSelectionDetails(select);
            updateDefinitionButton(select.value);
          });
          select.addEventListener('click', () => {
            showSelectionDetails(select);
            updateDefinitionButton(select.value);
          });
          select.addEventListener('focus', () => updateDefinitionButton(select.value));

          questionEl.appendChild(select);
          blankCounter += 1;
        } else {
          questionEl.appendChild(document.createTextNode(token));
        }
      });

      if (!blankCounter) {
        questionEl.textContent = 'No verbs found in this sentence. Try another.';
      }

      container.appendChild(questionEl);
      const hint = document.createElement('div');
      hint.className = 'meta';
      hint.innerHTML = `<span class="pill">Verbs</span>${blankCounter || '0'} recognised in this sentence.`;
      container.appendChild(hint);

      const cardContent = document.getElementById('cardContent');
      if (cardContent) {
        cardContent.innerHTML = '';
        cardContent.appendChild(container);
      }

      const checkBtn = document.getElementById('checkBtn');
      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');
      const nextBtn = document.getElementById('nextBtn');
      const revealBtn = document.getElementById('revealBtn');

      if (checkBtn) checkBtn.disabled = !blankCounter;
      if (againBtn) againBtn.disabled = true;
      if (mediumBtn) mediumBtn.disabled = true;
      if (easyBtn) easyBtn.disabled = true;
      if (nextBtn) nextBtn.disabled = false;
      if (revealBtn) revealBtn.disabled = false;
    }

    function nextCard() {
      if (!queue.length) {
        currentNode = null;
        renderNoCards('All cards in this deck are done for now.');
        return;
      }
      currentNode = queue.shift();
      hasChecked = false;
      renderCurrentCard();
      saveAppState();
    }

    function rateCurrentCard(difficulty) {
      if (!currentNode || !currentNode.entry) return;
      const entry = currentNode.entry;

      if (!hasChecked) {
        setFeedback('Check your answers before rating the card.', false);
        return;
      }

      let insertIndex;
      switch (difficulty) {
        case 'again':
          insertIndex = 1;
          break;
        case 'medium':
          insertIndex = 3;
          break;
        case 'easy':
        default:
          insertIndex = queue.length;
          break;
      }

      if (insertIndex > queue.length) insertIndex = queue.length;
      queue.splice(insertIndex, 0, currentNode);
      nextCard();
    }

    function checkAnswers() {
      if (!currentNode || !currentNode.entry) return;
      const selects = Array.from(document.querySelectorAll('select[id^="verb-"]'));
      if (!selects.length) return;

      let allCorrect = true;
      let missingChoice = false;

      selects.forEach(select => {
        clearSelectStatus(select);
        const value = select.value;
        if (!value) {
          missingChoice = true;
          return;
        }
        const correct = select.dataset.correct || '';
        const isCorrect = value.trim().toLowerCase() === correct.trim().toLowerCase();
        if (!isCorrect) {
          allCorrect = false;
        }
        select.classList.add(isCorrect ? 'select-correct' : 'select-wrong');
      });

      if (missingChoice) {
        setFeedback('Choose an answer for each verb before checking.', false);
        return;
      }

      hasChecked = true;
      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');

      if (againBtn) againBtn.disabled = false;
      if (mediumBtn) mediumBtn.disabled = false;
      if (easyBtn) easyBtn.disabled = false;

      saveAppState();

      if (allCorrect) {
        setFeedback('Correct! All verb forms match the sentence.', true);
        setExplanation('');
      } else {
        setFeedback('Not quite. Try adjusting your choices or use the SRS buttons.', false);
        setExplanation('');
      }
    }

    function revealOriginal() {
      if (!currentNode || !currentNode.entry) return;
      setExplanation(currentNode.entry.original || '');
    }

    function renderDefinitionContent(word, payload) {
      let html = `<strong>${word}</strong>`;
      if (payload.definitions?.length) {
        html += '<div>Definitions:</div><ul>' + payload.definitions.map(d => `<li>${d}</li>`).join('') + '</ul>';
      }
      if (payload.examples?.length) {
        html += '<div style="margin-top:8px;">Examples:</div><ul>' + payload.examples.map(e => `<li>${e}</li>`).join('') + '</ul>';
      }
      return html;
    }

    async function requestDefinition() {
      if (!selectedVerbForDefinition) return;
      setDefinitionStatus('Fetching definition from Wiktionary…');
      setDefinitionResult('');
      try {
        const result = await fetchDefinitionForWord(selectedVerbForDefinition);
        if (result.error) {
          setDefinitionStatus(result.error);
          setDefinitionResult('');
          return;
        }
        setDefinitionStatus('Definition loaded from Wiktionary.');
        setDefinitionResult(renderDefinitionContent(selectedVerbForDefinition, result));
      } catch (err) {
        setDefinitionStatus(`Error: ${err.message || String(err)}`);
        setDefinitionResult('');
      }
    }

    async function buildDeckFromInput() {
      const sourceEl = document.getElementById('sourceText');
      const cleanedEl = document.getElementById('cleanedText');
      const useCleaningEl = document.getElementById('useCleaning');

      if (!sourceEl || !cleanedEl || !useCleaningEl) return;

      const rawText = sourceEl.value.trim();
      if (!rawText) {
        alert('Please paste some French text first.');
        return;
      }

      setStatus('');
      setFeedback('');
      setExplanation('');
      setCardMeta('');
      renderNoCards('Preparing deck...');

      let workingText = rawText;

      try {
        if (useCleaningEl.checked) {
          setStatus('Cleaning text with Gemini using cleaningInstruction…');
          const cleaned = await callGemini(cleaningInstruction, rawText);
          cleanedEl.value = cleaned;
          workingText = cleaned;
        } else {
          cleanedEl.value = workingText;
        }

        const sentences = splitSentences(workingText);

        if (!sentences.length) {
          throw new Error('No sentences found after cleaning / splitting.');
        }

        const limited = sentences.slice(0, 10);
        deck = limited.map(sentence => buildCardFromSentence(sentence));
        initQueueFromDeck();
        setStatus(`Initialised deck with ${deck.length} sentences.`);
        nextCard();
        saveAppState();
      } catch (err) {
        console.error(err);
        setStatus(`Error: ${err.message || String(err)}`);
        renderNoCards('Could not build deck due to an error.');
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      flashcardCache = loadFlashcardCache();
      loadKey();

      loadVerbs()
        .then(() => {
          setStatus('Verb list ready.');
          restoreAppState();
        })
        .catch(err => {
          console.error(err);
          setStatus('Could not load verb list.');
          restoreAppState();
        });

      const saveKeyBtn = document.getElementById('saveKey');
      if (saveKeyBtn) {
        saveKeyBtn.addEventListener('click', () => {
          saveKey();
          setStatus('API key saved locally.');
        });
      }

      const sourceEl = document.getElementById('sourceText');
      if (sourceEl) {
        sourceEl.addEventListener('input', () => saveAppState());
      }

      const useCleaningEl = document.getElementById('useCleaning');
      if (useCleaningEl) {
        useCleaningEl.addEventListener('change', () => saveAppState());
      }

      const buildDeckBtn = document.getElementById('buildDeck');
      if (buildDeckBtn) {
        buildDeckBtn.addEventListener('click', () => {
          buildDeckFromInput();
        });
      }

      const checkBtn = document.getElementById('checkBtn');
      if (checkBtn) {
        checkBtn.addEventListener('click', () => {
          checkAnswers();
        });
      }

      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');

      if (againBtn) {
        againBtn.addEventListener('click', () => rateCurrentCard('again'));
      }
      if (mediumBtn) {
        mediumBtn.addEventListener('click', () => rateCurrentCard('medium'));
      }
      if (easyBtn) {
        easyBtn.addEventListener('click', () => rateCurrentCard('easy'));
      }

      const revealBtn = document.getElementById('revealBtn');
      if (revealBtn) {
        revealBtn.addEventListener('click', () => {
          revealOriginal();
        });
      }

      const nextBtn = document.getElementById('nextBtn');
      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          nextCard();
        });
      }

      const definitionBtn = document.getElementById('definitionBtn');
      if (definitionBtn) {
        definitionBtn.addEventListener('click', () => requestDefinition());
      }

      renderNoCards('No cards yet. Build a deck to begin.');
    });
  </script>
</body>
</html>
