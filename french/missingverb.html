
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>French Missing Verb Flashcards</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color-scheme: light dark;
    }

    body {
      margin: 0;
      padding: 0;
      background: #0f172a;
      color: #e5e7eb;
    }

    .app {
      max-width: 980px;
      margin: 0 auto;
      padding: 24px 16px 40px;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }

    h2 {
      font-size: 1.1rem;
      margin: 1.8rem 0 0.4rem;
    }

    p {
      margin: 0.2rem 0 0.4rem;
      color: #cbd5f5;
      font-size: 0.9rem;
    }

    textarea {
      width: 100%;
      box-sizing: border-box;
      min-height: 120px;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      resize: vertical;
      font-family: inherit;
      font-size: 0.95rem;
    }

    textarea[readonly] {
      opacity: 0.8;
    }

    label {
      display: block;
      font-size: 0.9rem;
      margin-bottom: 0.3rem;
    }

    .inline-label {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-top: 0.6rem;
      font-size: 0.9rem;
    }

    .inline-label input[type="checkbox"] {
      margin-right: 4px;
    }

    input[type="password"],
    input[type="text"] {
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-family: inherit;
      font-size: 0.9rem;
      min-width: 260px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 7px 14px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #10b981;
      color: #020617;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    button.secondary {
      background: #111827;
      color: #e5e7eb;
      border: 1px solid #1f2937;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .button-row {
      margin-top: 0.7rem;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .status {
      margin-top: 0.8rem;
      min-height: 1.2rem;
      font-size: 0.85rem;
      color: #a5b4fc;
      white-space: pre-line;
    }

    .card-shell {
      margin-top: 1rem;
      border-radius: 12px;
      border: 1px solid #1f2937;
      background: radial-gradient(circle at top left, #0f172a, #020617 52%);
      padding: 16px 14px;
      min-height: 120px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .card-question {
      font-size: 1rem;
      line-height: 1.4;
    }

    .card-question strong {
      font-weight: 600;
    }

    select {
      padding: 5px 10px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-family: inherit;
      font-size: 0.9rem;
      max-width: 100%;
    }

    .flashcard-footer {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 0.6rem;
    }

    .srs-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .srs-buttons button {
      flex: 0 0 auto;
      font-size: 0.85rem;
      padding-inline: 12px;
    }

    .srs-buttons button.again {
      background: #b91c1c;
      color: #f9fafb;
    }

    .srs-buttons button.medium {
      background: #4b5563;
      color: #f9fafb;
    }

    .srs-buttons button.easy {
      background: #22c55e;
      color: #052e16;
    }

    .feedback {
      font-size: 0.9rem;
      min-height: 1.1rem;
    }

    .feedback.ok {
      color: #6ee7b7;
    }

    .feedback.bad {
      color: #fecaca;
    }

    .explanation {
      font-size: 0.85rem;
      color: #cbd5f5;
      margin-top: 4px;
    }

    .meta {
      font-size: 0.8rem;
      color: #9ca3af;
      margin-top: 0.4rem;
    }

    .pill {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #1f2937;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-right: 6px;
    }

    @media (min-width: 860px) {
      .layout-two-column {
        display: grid;
        grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
        gap: 20px;
        align-items: flex-start;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>French Missing Verb Flashcards</h1>
    <p>Paste a block of French, optionally clean it with Gemini, then build a small deck of verb-cloze flashcards.</p>

    <!-- API key -->
    <section>
      <h2>API key</h2>
      <label for="apiKey">Gemini API key</label>
      <div class="button-row">
        <input id="apiKey" type="password" autocomplete="off" placeholder="Your Gemini API key" />
        <button id="saveKey" class="secondary" type="button">Save key locally</button>
      </div>
      <p class="meta">Stored in your browser’s localStorage only.</p>
    </section>

    <div class="layout-two-column">
      <!-- Left: input & cleaning -->
      <section>
        <h2>1. Input text</h2>
        <label for="sourceText">Raw French sentences (one per line, or a paragraph without punctuation)</label>
        <textarea id="sourceText" placeholder="Eg: il faut que je parte demain matin&#10;je voudrais apprendre le français rapidement"></textarea>

        <label class="inline-label">
          <input type="checkbox" id="useCleaning" checked />
          Use Gemini to clean / punctuate first (uses <code>cleaningInstruction</code>)
        </label>

        <div class="button-row">
          <button id="buildDeck" type="button">Build flashcard deck (max 10)</button>
        </div>

        <div id="status" class="status"></div>
      </section>

      <!-- Right: cleaned text -->
      <section>
        <h2>2. Cleaned sentences</h2>
        <p>This shows the result of the cleaning step before flashcards are built.</p>
        <textarea id="cleanedText" readonly placeholder="Cleaned sentences will appear here."></textarea>
      </section>
    </div>

    <!-- Flashcard area -->
    <section>
      <h2>3. Flashcards</h2>
      <p>Each flashcard hides one verb and offers a dropdown list of conjugations.</p>

      <div id="cardShell" class="card-shell">
        <div id="cardContent" class="card-question">
          No cards yet. Build a deck to begin.
        </div>

        <div class="flashcard-footer">
          <div class="button-row">
            <button id="checkBtn" type="button" disabled>Check answer</button>
            <button id="nextBtn" type="button" class="secondary" disabled>Next card</button>
            <button id="revealBtn" type="button" class="secondary" disabled>Reveal explanation</button>
          </div>
          <div class="srs-buttons">
            <button id="againBtn" type="button" class="again" disabled>Again</button>
            <button id="mediumBtn" type="button" class="medium" disabled>Medium</button>
            <button id="easyBtn" type="button" class="easy" disabled>Easy</button>
          </div>
          <div id="feedback" class="feedback"></div>
          <div id="explanation" class="explanation"></div>
          <div id="cardMeta" class="meta"></div>
        </div>
      </div>
    </section>
  </div>

  <script>
    // --- System instructions used for the model ---

    const cleaningInstruction =
      "I'll give you some text without punctuation and can you fix them in to sentences please. Do not say anything, just return the fixed text.";

    const missingVerbInstruction = `I say:
Tu dois terminer ton travail avant de sortir ?

YOU REPLY IN THIS FORMAT ONLY!! Choose first verb!
[
Tu ____ terminer ton travail avant de sortir ?
| dois (Indicatif – Présent)
| devais (Indicatif – Imparfait)
| devras (Indicatif – Futur simple)
| as dû (Indicatif – Passé composé)
| avais dû (Indicatif – Plus-que-parfait)
| auras dû (Indicatif – Futur antérieur)
| dus (Indicatif – Passé simple)
| eus dû (Indicatif – Passé antérieur)
| doives (Subjonctif – Présent)
| aies dû (Subjonctif – Passé)
| dusses (Subjonctif – Imparfait)
| eusses dû (Subjonctif – Plus-que-parfait)
| devrais (Conditionnel – Présent)
| aurais dû (Conditionnel – Passé)
| dois (Impératif)
| devant (Participe présent)
| dû (Participe passé)
<Dois>
**Tu dois terminer ton travail avant de sortir? (Do you have to finish your work before going out?)**
];`;

    // --- API key helpers ---

    function loadKey() {
      const input = document.getElementById('apiKey');
      const stored = localStorage.getItem('geminiApiKey');

      if (input && input.value.trim()) {
        return input.value.trim();
      }

      if (stored) {
        if (input && !input.value) {
          input.value = stored;
        }
        return stored;
      }

      return null;
    }

    function saveKey() {
      const input = document.getElementById('apiKey');
      if (!input) return;
      const value = input.value.trim();
      if (value) {
        localStorage.setItem('geminiApiKey', value);
      }
    }

    // --- Single central Gemini call, using the system instructions above ---

    async function callGemini(systemInstruction, userContent) {
      const key = loadKey();
      if (!key) throw new Error('Missing API key');

      const response = await fetch(
        `https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=${key}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            systemInstruction: { parts: [{ text: systemInstruction }] },
            contents: [{ parts: [{ text: userContent }] }]
          })
        }
      );

      const raw = await response.text();
      let data;
      try {
        data = JSON.parse(raw);
      } catch (e) {
        data = null;
      }

      if (!response.ok || data?.error) {
        const err = new Error(
          data?.error?.message || `Request failed (${response.status})`
        );
        err.raw = raw;
        throw err;
      }

      const botText = data?.candidates?.[0]?.content?.parts?.[0]?.text;
      if (!botText) throw new Error('No content returned.');
      return botText;
    }

    // --- Flashcard cache (per sentence) ---

    const FLASHCARD_CACHE_KEY = 'geminiVerbFlashcardCache';
    let flashcardCache = {};

    function loadFlashcardCache() {
      try {
        const raw = localStorage.getItem(FLASHCARD_CACHE_KEY);
        if (!raw) return {};
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (e) {
        console.warn('Could not load flashcard cache', e);
        return {};
      }
    }

    function saveFlashcardCache() {
      try {
        localStorage.setItem(FLASHCARD_CACHE_KEY, JSON.stringify(flashcardCache));
      } catch (e) {
        console.warn('Could not save flashcard cache', e);
      }
    }

    // --- Flashcard data structures and state ---

    // Each deck entry is { sentence, card: null | cardObject }
    let deck = [];
    // queue elements are { entry, id }
    let queue = [];
    let currentNode = null;
    let hasChecked = false;

    // Card shape:
    // {
    //   question: "Tu ____ ... ?",
    //   options: [{ label, value }],
    //   correctValue: "Dois",
    //   explanation: "Tu dois ... (Do you ...)",
    //   originalSentence: "Tu dois terminer ... ?",
    //   raw: "<full raw model reply>"
    // }

    function parseFlashcardResponse(raw) {
      const lines = raw
        .split('\n')
        .map(l => l.trim())
        .filter(Boolean);

      if (!lines.length) {
        throw new Error('Empty response from model for flashcard.');
      }

      // Question line: look for the line with the blank
      let question = lines.find(l => l.includes('____'));
      if (!question) {
        // fallback: first non-bracket line
        question = lines.find(l => !l.startsWith('[') && !l.startsWith('|')) || lines[0];
      }

      // Option lines: those starting with '|'
      const optionLines = lines.filter(l => l.startsWith('|'));
      if (!optionLines.length) {
        throw new Error('No options found in model reply.');
      }

      const options = optionLines.map(line => {
        const label = line.replace(/^\|\s*/, '');
        const m = label.match(/^(.+?)\s*\(/);
        const value = m ? m[1].trim() : label.trim();
        return { label, value };
      });

      // Correct form: between < and >
      const answerLine = lines.find(l => l.startsWith('<') && l.endsWith('>'));
      if (!answerLine) {
        throw new Error('No correct answer marker <...> found.');
      }
      const correctValue = answerLine.slice(1, -1).trim();

      // Explanation: line that starts with ** and ends with **
      const explanationLine = lines.find(l => l.startsWith('**') && l.endsWith('**'));
      const explanation = explanationLine
        ? explanationLine.replace(/^\*\*/, '').replace(/\*\*$/, '').trim()
        : '';

      return {
        question,
        options,
        correctValue,
        explanation,
        raw
      };
    }

    function initQueueFromDeck() {
      queue = deck.map((entry, idx) => ({ entry, id: idx }));
      currentNode = null;
      hasChecked = false;
    }

    // --- UI helpers ---

    function setStatus(text) {
      const el = document.getElementById('status');
      if (el) el.textContent = text || '';
    }

    function setFeedback(text, ok) {
      const fb = document.getElementById('feedback');
      if (!fb) return;
      fb.textContent = text || '';
      fb.classList.remove('ok', 'bad');
      if (!text) return;
      fb.classList.add(ok ? 'ok' : 'bad');
    }

    function setExplanation(text) {
      const el = document.getElementById('explanation');
      if (el) el.textContent = text || '';
    }

    function setCardMeta(text) {
      const el = document.getElementById('cardMeta');
      if (el) el.textContent = text || '';
    }

    function setControlsEnabled(enabled) {
      const checkBtn = document.getElementById('checkBtn');
      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');
      const nextBtn = document.getElementById('nextBtn');
      const revealBtn = document.getElementById('revealBtn');

      [checkBtn, againBtn, mediumBtn, easyBtn, nextBtn, revealBtn].forEach(btn => {
        if (btn) btn.disabled = !enabled;
      });
    }

    function renderNoCards(message) {
      const cardContent = document.getElementById('cardContent');
      if (cardContent) {
        cardContent.innerHTML = message || 'No cards available.';
      }
      setFeedback('');
      setExplanation('');
      setCardMeta('');
      setControlsEnabled(false);
    }

    // --- Lazy loading: ensure the current node has a card, using cache if possible ---

    async function ensureCurrentCardLoaded() {
      if (!currentNode || !currentNode.entry) return null;

      const entry = currentNode.entry;
      if (entry.card) {
        // Already loaded in memory
        return entry.card;
      }

      const sentence = entry.sentence;
      if (!sentence) {
        throw new Error('Missing sentence for this card.');
      }

      // Try cache (per sentence)
      const cached = flashcardCache[sentence];
      if (cached) {
        entry.card = cached;
        return entry.card;
      }

      // If not in cache, generate now
      setStatus(`Generating flashcard for sentence ${currentNode.id + 1}…`);
      const rawFlashcard = await callGemini(missingVerbInstruction, sentence);
      const parsed = parseFlashcardResponse(rawFlashcard);
      parsed.originalSentence = sentence;

      entry.card = parsed;
      flashcardCache[sentence] = parsed;
      saveFlashcardCache();

      return entry.card;
    }

    // --- Rendering current card (async because of lazy loading) ---

    async function renderCurrentCard() {
      const cardContent = document.getElementById('cardContent');
      if (!cardContent) return;

      if (!currentNode || !currentNode.entry) {
        renderNoCards('Deck finished. Build a new one to continue.');
        return;
      }

      // Disable everything while loading this card
      setControlsEnabled(false);
      hasChecked = false;
      setFeedback('');
      setExplanation('');
      setCardMeta('');

      const nextBtn = document.getElementById('nextBtn');
      const revealBtn = document.getElementById('revealBtn');

      if (nextBtn) nextBtn.disabled = true;
      if (revealBtn) revealBtn.disabled = true;

      let card;
      try {
        card = await ensureCurrentCardLoaded();
      } catch (err) {
        console.error(err);
        setStatus(`Error creating flashcard: ${err.message || String(err)}`);
        renderNoCards('Could not create this card.');
        return;
      } finally {
        setStatus('');
      }

      if (!card) {
        renderNoCards('Could not create this card.');
        return;
      }

      setCardMeta(`Card ${currentNode.id + 1} of ${deck.length}`);

      const parts = card.question.split('____');
      const before = parts[0] || '';
      const after = parts[1] || '';

      const container = document.createElement('div');

      const questionEl = document.createElement('div');
      questionEl.className = 'card-question';

      const beforeSpan = document.createElement('span');
      beforeSpan.textContent = before;

      const afterSpan = document.createElement('span');
      afterSpan.textContent = after;

      const select = document.createElement('select');
      select.id = 'answerSelect';

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = '— choisir une forme —';
      placeholder.disabled = true;
      placeholder.selected = true;
      select.appendChild(placeholder);

      card.options.forEach(opt => {
        const o = document.createElement('option');
        o.value = opt.value;
        o.textContent = opt.label;
        select.appendChild(o);
      });

      questionEl.appendChild(beforeSpan);
      questionEl.appendChild(document.createTextNode(' '));
      questionEl.appendChild(select);
      questionEl.appendChild(document.createTextNode(' '));
      questionEl.appendChild(afterSpan);

      container.appendChild(questionEl);

      const hint = document.createElement('div');
      hint.className = 'meta';
      hint.innerHTML = `<span class="pill">Verb</span>Choose the correct conjugation of the missing verb.`;
      container.appendChild(hint);

      cardContent.innerHTML = '';
      cardContent.appendChild(container);

      // After rendering: enable only "Check" initially
      const checkBtn = document.getElementById('checkBtn');
      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');

      if (checkBtn) checkBtn.disabled = false;
      if (againBtn) againBtn.disabled = true;
      if (mediumBtn) mediumBtn.disabled = true;
      if (easyBtn) easyBtn.disabled = true;
      if (nextBtn) nextBtn.disabled = true;
      if (revealBtn) revealBtn.disabled = true;
    }

    // --- Queue navigation (async because renderCurrentCard is async) ---

    async function nextCard() {
      if (!queue.length) {
        currentNode = null;
        renderNoCards('All cards in this deck are done for now.');
        return;
      }
      currentNode = queue.shift();
      await renderCurrentCard();
    }

    function rateCurrentCard(difficulty) {
      if (!currentNode || !currentNode.entry) return;
      const entry = currentNode.entry;

      if (!entry.card) {
        setFeedback('This card is still loading. Please wait.', false);
        return;
      }

      if (!hasChecked) {
        setFeedback('Check your answer before rating the card.', false);
        return;
      }

      let insertIndex;
      switch (difficulty) {
        case 'again':
          insertIndex = 1;
          break;
        case 'medium':
          insertIndex = 3;
          break;
        case 'easy':
        default:
          insertIndex = queue.length;
          break;
      }

      if (insertIndex > queue.length) insertIndex = queue.length;
      queue.splice(insertIndex, 0, currentNode);
      // Move on to next card
      nextCard();
    }

    function checkAnswer() {
      if (!currentNode || !currentNode.entry) return;
      const entry = currentNode.entry;
      const card = entry.card;

      if (!card) {
        setFeedback('This card is still loading. Please wait.', false);
        return;
      }

      const select = document.getElementById('answerSelect');
      if (!select) return;

      const value = select.value;
      if (!value) {
        setFeedback('Please choose an answer from the list.', false);
        return;
      }

      const normalisedValue = value.trim().toLowerCase();
      const normalisedCorrect = card.correctValue.trim().toLowerCase();

      const isCorrect = normalisedValue === normalisedCorrect;

      const checkBtn = document.getElementById('checkBtn');
      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');
      const nextBtn = document.getElementById('nextBtn');
      const revealBtn = document.getElementById('revealBtn');

      if (isCorrect) {
        setFeedback(`Correct: ${card.correctValue}`, true);
        // Automatically reveal explanation on correct
        setExplanation(card.explanation || '');

        // Disable SRS & reveal; enable Next; disable Check
        if (againBtn) againBtn.disabled = true;
        if (mediumBtn) mediumBtn.disabled = true;
        if (easyBtn) easyBtn.disabled = true;
        if (revealBtn) revealBtn.disabled = true;
        if (checkBtn) checkBtn.disabled = true;
        if (nextBtn) nextBtn.disabled = false;
      } else {
        setFeedback(`Not quite. Correct answer will be hidden until you reveal it.`, false);
        // Hide explanation until user chooses to reveal
        setExplanation('');

        // Enable SRS buttons, enable Reveal, keep Next disabled
        if (againBtn) againBtn.disabled = false;
        if (mediumBtn) mediumBtn.disabled = false;
        if (easyBtn) easyBtn.disabled = false;
        if (revealBtn) revealBtn.disabled = false;
        if (nextBtn) nextBtn.disabled = true;
      }

      hasChecked = true;
    }

    function revealExplanation() {
      if (!currentNode || !currentNode.entry) return;
      const entry = currentNode.entry;
      const card = entry.card;
      if (!card) return;
      setExplanation(card.explanation || '');
    }

    function goToNextCard() {
      // On correct, we do not reinsert this card into the queue:
      // it's already been shifted out when we first showed it,
      // and we simply move on.
      nextCard();
    }

    // --- Deck building workflow (cleans + sets up sentences; cards are lazy-loaded) ---

    async function buildDeckFromInput() {
      const sourceEl = document.getElementById('sourceText');
      const cleanedEl = document.getElementById('cleanedText');
      const useCleaningEl = document.getElementById('useCleaning');

      if (!sourceEl || !cleanedEl || !useCleaningEl) return;

      const rawText = sourceEl.value.trim();
      if (!rawText) {
        alert('Please paste some French text first.');
        return;
      }

      setStatus('');
      setFeedback('');
      setExplanation('');
      setCardMeta('');
      renderNoCards('Preparing deck...');

      let workingText = rawText;

      try {
        if (useCleaningEl.checked) {
          setStatus('Cleaning text with Gemini using cleaningInstruction…');
          const cleaned = await callGemini(cleaningInstruction, rawText);
          cleanedEl.value = cleaned;
          workingText = cleaned;
        } else {
          cleanedEl.value = workingText;
        }

        const sentences = workingText
          .split(/\r?\n/)
          .map(s => s.trim())
          .filter(Boolean);

        if (!sentences.length) {
          throw new Error('No sentences found after cleaning / splitting.');
        }

        const limited = sentences.slice(0, 10);

        // Lazy: keep only sentences here, no per-sentence AI call yet
        deck = limited.map(sentence => ({
          sentence,
          card: null
        }));

        initQueueFromDeck();
        setStatus(`Initialised deck with ${deck.length} sentences. Each flashcard is generated only when you see it.`);
        await nextCard();
      } catch (err) {
        console.error(err);
        setStatus(`Error: ${err.message || String(err)}`);
        renderNoCards('Could not build deck due to an error.');
      }
    }

    // --- Wire up UI once DOM is ready ---

    document.addEventListener('DOMContentLoaded', () => {
      // Load caches
      flashcardCache = loadFlashcardCache();

      // Prefill key from localStorage
      loadKey();

      const saveKeyBtn = document.getElementById('saveKey');
      if (saveKeyBtn) {
        saveKeyBtn.addEventListener('click', () => {
          saveKey();
          setStatus('API key saved locally.');
        });
      }

      const buildDeckBtn = document.getElementById('buildDeck');
      if (buildDeckBtn) {
        buildDeckBtn.addEventListener('click', () => {
          buildDeckFromInput();
        });
      }

      const checkBtn = document.getElementById('checkBtn');
      if (checkBtn) {
        checkBtn.addEventListener('click', () => {
          checkAnswer();
        });
      }

      const againBtn = document.getElementById('againBtn');
      const mediumBtn = document.getElementById('mediumBtn');
      const easyBtn = document.getElementById('easyBtn');

      if (againBtn) {
        againBtn.addEventListener('click', () => rateCurrentCard('again'));
      }
      if (mediumBtn) {
        mediumBtn.addEventListener('click', () => rateCurrentCard('medium'));
      }
      if (easyBtn) {
        easyBtn.addEventListener('click', () => rateCurrentCard('easy'));
      }

      const revealBtn = document.getElementById('revealBtn');
      if (revealBtn) {
        revealBtn.addEventListener('click', () => {
          revealExplanation();
        });
      }

      const nextBtn = document.getElementById('nextBtn');
      if (nextBtn) {
        nextBtn.addEventListener('click', () => {
          goToNextCard();
        });
      }

      // Initial state
      renderNoCards('No cards yet. Build a deck to begin.');
    });
  </script>
</body>
</html>
