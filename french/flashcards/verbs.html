<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>French Conjugation Stave</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      --bg: #0f172a;
      --panel: #111827;
      --border: #1f2937;
      --muted: #94a3b8;
      --text: #f3f4f6;
      --accent: #38bdf8;
      --accent-fg: #082f49;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
      --lane-bg: rgba(255, 255, 255, 0.02);
      --lane-highlight: rgba(148, 163, 184, 0.1);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      overflow-x: hidden;
    }

    header {
      max-width: 1100px;
      margin: 0 auto;
      padding: 24px 20px 6px;
    }

    h1 { margin: 0 0 6px; font-size: 1.7rem; }
    p.lead { margin: 0; color: var(--muted); font-size: 0.95rem; }

    main {
      max-width: 1100px;
      margin: 0 auto;
      padding: 6px 20px 30px;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }

    label { font-size: 0.85rem; color: var(--muted); display: block; margin-bottom: 6px; }

    input[type="number"], input[type="range"] {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0b1220;
      color: var(--text);
      padding: 8px 10px;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      background: var(--accent);
      color: var(--accent-fg);
      font-weight: 700;
      cursor: pointer;
      width: 100%;
      transition: opacity 0.2s;
    }
    button:disabled { opacity: 0.5; cursor: default; }

    .stats {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 0.95rem;
      margin-bottom: 8px;
    }
    .stats strong { color: var(--text); }

    /* STAVE CONTAINER */
    .stave {
      position: relative;
      height: 380px;
      overflow: hidden;
      background: #0b1120;
      border-radius: 8px;
      border: 1px solid var(--border);
      /* CSS Variables for Gate Positions, updated by JS */
      --gate-a-pos: 66%;
      --gate-b-pos: 33%;
    }

    .lanes {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-rows: repeat(6, 1fr);
      z-index: 1;
    }

    .lane {
      border-bottom: 1px solid var(--border);
      position: relative;
      /* Labels are absolutely positioned inside, so we don't need flex for them anymore */
      width: 100%;
    }
    .lane:last-child { border-bottom: none; }
    
    .lane:nth-child(even) { background: var(--lane-bg); }

    /* 
       LANE LABELS 
       These are anchored to the gate positions defined in CSS variables
    */
    .lane-text {
      position: absolute;
      top: 50%;
      transform: translate(-100%, -50%); /* Center vertical, align right edge to 'left' pos */
      font-weight: 700;
      font-size: 0.95rem;
      color: #fff;
      text-shadow: 0 1px 4px rgba(0,0,0,0.8);
      white-space: nowrap;
      padding-right: 12px; /* Spacing between text and gate line */
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    /* Position specific label groups */
    .lane-text.tense { left: var(--gate-a-pos); color: var(--warning); }
    .lane-text.person { left: var(--gate-b-pos); color: #e5e7eb; }

    /* Hiding states (applied to parent .lanes) */
    .lanes.passed-tense .lane-text.tense { opacity: 0; }
    .lanes.passed-person .lane-text.person { opacity: 0; }

    .lane.correct { background: rgba(34, 197, 94, 0.15); }
    .lane.flash { animation: flash 0.4s ease; }
    @keyframes flash {
      0% { background: var(--accent); opacity: 0.2; }
      100% { background: transparent; }
    }

    /* GATES */
    .gate {
      position: absolute;
      top: 0; bottom: 0;
      width: 4px;
      border-radius: 99px;
      z-index: 5;
    }

    #gate-a { left: var(--gate-a-pos); background: var(--warning); box-shadow: 0 0 15px rgba(245, 158, 11, 0.3); }
    #gate-b { left: var(--gate-b-pos); background: #e5e7eb; box-shadow: 0 0 15px rgba(255, 255, 255, 0.2); }

    .gate-label {
      position: absolute;
      top: 0;
      transform: translateX(-50%);
      padding: 4px 10px;
      border-bottom-left-radius: 8px;
      border-bottom-right-radius: 8px;
      font-size: 0.7rem;
      font-weight: 800;
      z-index: 6;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #gate-a-label { left: var(--gate-a-pos); background: var(--warning); color: #000; }
    #gate-b-label { left: var(--gate-b-pos); background: #e5e7eb; color: #000; }

    .gate.stamped { background: var(--success); box-shadow: 0 0 20px rgba(34, 197, 94, 0.6); }
    .gate.stamped + .gate-label { background: var(--success); color: #fff; }

    /* TOKEN */
    .token {
      position: absolute;
      z-index: 10;
      width: 220px;
      height: 48px;
      /* Centering content */
      display: flex;
      align-items: center;
      justify-content: center;
      
      background: var(--accent); 
      color: var(--accent-fg);
      border: 2px solid #fff;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      
      font-weight: 700;
      font-size: 1rem;
      text-align: center;
      white-space: nowrap;
      
      will-change: transform;
      /* We handle movement in JS, transition only for snap-events if needed */
    }

    .token.success { background: var(--success); border-color: #fff; color: #000; }
    .token.fail { background: var(--danger); border-color: #fff; color: #fff; }

    .message { min-height: 1.5rem; color: var(--muted); font-weight: 500; margin-top: 4px;}
    .message.error { color: var(--danger); }
    .message.success { color: var(--success); }

    .mobile-controls { display: none; gap: 12px; margin-top: 12px; }
    .mobile-controls button { flex: 1; padding: 20px 0; font-size: 1.2rem; }
    
    @media (max-width: 780px) {
      .mobile-controls { display: flex; }
      .stave { height: 340px; }
      .lane-text { font-size: 0.8rem; }
    }
  </style>
</head>
<body>
  <header>
    <h1>French Conjugation Stave</h1>
    <p class="lead">Pass the Tense Gate first (Right), then the Person Gate (Left).</p>
  </header>

  <main>
    <section class="panel controls">
      <div>
        <label for="lives">Lives</label>
        <input id="lives" type="number" min="1" max="9" value="3" />
      </div>
      <div>
        <label for="speed">Speed</label>
        <input id="speed" type="range" min="40" max="250" value="100" />
      </div>
      <div>
        <label><input id="show-infinitive" type="checkbox" checked /> Show Infinitive</label>
        <button id="start">Start Run</button>
      </div>
    </section>

    <section class="panel">
      <div class="stats">
        <div>Lives: <strong id="lives-display">3</strong></div>
        <div>Score: <strong id="score-display">0</strong></div>
        <div>Target: <strong id="gate-display" style="color:var(--accent)">Tense Gate</strong></div>
      </div>
      
      <p id="message" class="message">Load verb data to begin.</p>
      
      <div class="stave" id="stave">
        <div class="lanes" id="lanes">
          <!-- Lanes injected by JS -->
        </div>
        
        <!-- Gates -->
        <div class="gate" id="gate-a"></div>
        <div class="gate-label" id="gate-a-label">TENSE</div>
        
        <div class="gate" id="gate-b"></div>
        <div class="gate-label" id="gate-b-label">PERSON</div>
        
        <!-- Token -->
        <div class="token" id="token">Loading...</div>
      </div>

      <div class="mobile-controls">
        <button id="move-up">⬆️ Up</button>
        <button id="move-down">⬇️ Down</button>
      </div>
    </section>
  </main>

  <script>
    const DATA_PATH = "../dir/words/BigVerbList.json";

    // Data Config
    const PERSON_LABELS = ["JE", "TU", "IL / ELLE", "NOUS", "VOUS", "ILS / ELLES"];
    // Tense labels only apply to specific rows (1, 2, 3) corresponding to Present, Imperfect, Passé
    // Row 0, 4, 5 have no tense label in this specific game logic
    const TENSE_LABELS_MAP = {
      1: "PRÉSENT",
      2: "IMPARFAIT",
      3: "PASSÉ COMPOSÉ"
    };
    
    // Tense Logic Mapping
    const TENSE_DATA = [
        { label: "PRÉSENT", tense: "Présent", laneIndex: 1 },
        { label: "IMPARFAIT", tense: "Imparfait", laneIndex: 2 },
        { label: "PASSÉ COMPOSÉ", tense: "Passé composé", laneIndex: 3 }
    ];

    const state = {
      data: [],
      isRunning: false,
      lives: 3,
      score: 0,
      speed: 100,
      token: null,
      laneIndex: 2, 
      x: 0,
      gateA: 0, // Tense (Right)
      gateB: 0, // Person (Left)
      gateAReached: false,
      gateBReached: false,
      lastTime: null,
      paused: false
    };

    const els = {
      stave: document.getElementById("stave"),
      lanes: document.getElementById("lanes"),
      token: document.getElementById("token"),
      gateA: document.getElementById("gate-a"),
      gateB: document.getElementById("gate-b"),
      msg: document.getElementById("message"),
      score: document.getElementById("score-display"),
      lives: document.getElementById("lives-display"),
      target: document.getElementById("gate-display"),
      startBtn: document.getElementById("start")
    };

    // --- SETUP ---

    function initLanes() {
      els.lanes.innerHTML = "";
      for (let i = 0; i < 6; i++) {
        const lane = document.createElement("div");
        lane.className = "lane";
        
        // Person Label (Left Gate)
        const pLabel = document.createElement("span");
        pLabel.className = "lane-text person";
        pLabel.textContent = PERSON_LABELS[i];
        
        // Tense Label (Right Gate)
        const tLabel = document.createElement("span");
        tLabel.className = "lane-text tense";
        tLabel.textContent = TENSE_LABELS_MAP[i] || ""; // Empty if not a tense row
        
        lane.appendChild(pLabel);
        lane.appendChild(tLabel);
        els.lanes.appendChild(lane);
      }
    }

    function resizeGates() {
      const w = els.stave.getBoundingClientRect().width;
      // Define positions (Tense is Right/First, Person is Left/Second)
      state.gateA = w * 0.66;
      state.gateB = w * 0.30;
      
      // Update CSS variables so CSS handles label positioning
      els.stave.style.setProperty('--gate-a-pos', `${state.gateA}px`);
      els.stave.style.setProperty('--gate-b-pos', `${state.gateB}px`);
    }

    // --- GAME LOGIC ---

    const PERSON_INDEX = new Map([
      ["1st person singular", 0],
      ["2nd person singular", 1],
      ["3rd person singular", 2],
      ["1st person plural", 3],
      ["2nd person plural", 4],
      ["3rd person plural", 5]
    ]);

    const TENSE_ALIASES = new Map([
      ["Present", "PRÉSENT"],
      ["Présent", "PRÉSENT"],
      ["Imperfect", "IMPARFAIT"],
      ["Imparfait", "IMPARFAIT"],
      ["Perfect (Passé Composé)", "PASSÉ COMPOSÉ"],
      ["Passé composé", "PASSÉ COMPOSÉ"]
    ]);

    function extractVerbName(raw) {
      if (!raw) return "";
      const trimmed = String(raw).trim();
      if (!trimmed) return "";
      const parts = trimmed.split(/\s+/);
      return parts[parts.length - 1];
    }

    function buildVerbEntries(data) {
      const entries = [];
      data.forEach((entry, index) => {
        if (entry && Array.isArray(entry.conjugations)) {
          entry.conjugations.forEach((conjugation) => {
            if (!conjugation || conjugation.mood !== "Indicative") return;
            const tenseLabel = TENSE_ALIASES.get(conjugation.tense);
            if (!tenseLabel) return;
            const tenseData = TENSE_DATA.find((tense) => tense.label === tenseLabel);
            if (!tenseData) return;
            const personIndex = PERSON_INDEX.get(conjugation.person);
            if (personIndex === undefined) return;
            const conjugated = extractVerbName(conjugation.conjugated_form || "");
            if (!conjugated) return;

            const rawVerbName = entry.verb || conjugated;
            entries.push({
              verb: extractVerbName(rawVerbName),
              conjugated_form: conjugated,
              tense: tenseData.label,
              personIndex,
              tenseLaneIndex: tenseData.laneIndex
            });
          });
          return;
        }

        // Fallback: distribute entries across tense/person lanes
        const personIndex = index % 6;
        const tenseIdx = Math.floor(index / 6) % 3;
        const fallbackLabel = TENSE_DATA[tenseIdx].label;
        const fallbackVerb = entry?.french || entry?.verb || String(entry || "").trim();
        if (!fallbackVerb) return;

        const cleanedFallbackVerb = extractVerbName(fallbackVerb);
        if (!cleanedFallbackVerb) return;

        entries.push({
          verb: cleanedFallbackVerb,
          conjugated_form: cleanedFallbackVerb,
          tense: fallbackLabel,
          personIndex,
          tenseLaneIndex: TENSE_DATA[tenseIdx].laneIndex
        });
      });
      return entries;
    }

    function pickToken() {
        if(!state.data.length) return;
        const entry = state.data[Math.floor(Math.random() * state.data.length)];
        state.token = entry;
        
        const showInf = document.getElementById("show-infinitive").checked;
        els.token.textContent = showInf 
            ? `${entry.conjugated_form} (${entry.verb})` 
            : entry.conjugated_form;
            
        els.token.classList.remove("success", "fail");
    }

    function resetTokenPosition() {
        // Start far right
        const w = els.stave.clientWidth;
        state.x = w + 20; 
        state.laneIndex = 2; // Default safe middle
        
        state.gateAReached = false;
        state.gateBReached = false;
        
        // Reset Visuals
        els.lanes.className = "lanes"; // Removes .passed-tense .passed-person
        els.gateA.classList.remove("stamped");
        els.gateB.classList.remove("stamped");
        els.target.textContent = "Tense Gate";
        els.target.style.color = "var(--warning)";
        
        positionToken();
    }

    function positionToken() {
        const laneH = els.stave.clientHeight / 6;
        const y = (state.laneIndex * laneH) + (laneH/2) - (els.token.offsetHeight/2);
        els.token.style.transform = `translate(${state.x}px, ${y}px)`;
    }

    function moveLane(dir) {
        if(!state.isRunning || state.paused) return;
        
        // If we haven't passed Tense gate, limit to middle 3 lanes? 
        // Or allow movement everywhere but punish wrong lanes?
        // User requested ability to see labels, implies free movement. 
        // We will restrict Tense logic to lanes 1,2,3 but allow player to move to others (and fail).
        
        const next = state.laneIndex + dir;
        if(next >= 0 && next <= 5) {
            state.laneIndex = next;
            positionToken();
        }
    }

    function handleFail(msg) {
        state.lives--;
        els.lives.textContent = state.lives;
        els.msg.textContent = msg;
        els.msg.className = "message error";
        els.token.classList.add("fail");
        state.paused = true;
        
        setTimeout(() => {
            state.paused = false;
            if(state.lives > 0) {
                pickToken();
                resetTokenPosition();
            } else {
                state.isRunning = false;
                els.msg.textContent = "Game Over. Press Start.";
                els.startBtn.disabled = false;
            }
        }, 1200);
    }

    function checkGate(type) {
        if(type === 'tense') {
            const correctLane = state.token.tenseLaneIndex;
            if(state.laneIndex === correctLane) {
                // Success Tense
                els.gateA.classList.add("stamped");
                els.msg.textContent = "Tense Good! Now Match Person.";
                els.msg.className = "message success";
                els.lanes.classList.add("passed-tense"); // Hides Tense labels
                els.target.textContent = "Person Gate";
                els.target.style.color = "#fff";
                return true;
            } else {
                handleFail(`Wrong Tense! Expected: ${state.token.tense}`);
                return false;
            }
        } 
        else if(type === 'person') {
            const correctLane = state.token.personIndex;
            if(state.laneIndex === correctLane) {
                // Success Person
                els.gateB.classList.add("stamped");
                els.msg.textContent = "Person Good!";
                els.msg.className = "message success";
                els.lanes.classList.add("passed-person"); // Hides Person labels
                els.target.textContent = "Finish!";
                return true;
            } else {
                const pLabel = PERSON_LABELS[correctLane];
                handleFail(`Wrong Person! Expected: ${pLabel}`);
                return false;
            }
        }
        return false;
    }

    function animate(time) {
        if(!state.isRunning) return;
        if(!state.lastTime) state.lastTime = time;
        const delta = (time - state.lastTime) / 1000;
        state.lastTime = time;

        if(!state.paused) {
            state.x -= state.speed * delta;
            positionToken();

            // Right-to-Left: Token X decreases.
            // Gate A is at x=66%, Gate B is at x=33%. Token starts at x=100%+.
            
            // Check Tense Gate (First interaction)
            // Token left edge passes Gate A
            if(!state.gateAReached && state.x <= state.gateA) {
                state.gateAReached = true;
                if(!checkGate('tense')) return requestAnimationFrame(animate);
            }

            // Check Person Gate (Second interaction)
            if(state.gateAReached && !state.gateBReached && state.x <= state.gateB) {
                state.gateBReached = true;
                if(!checkGate('person')) return requestAnimationFrame(animate);
            }

            // Check Finish (Left edge)
            if(state.gateBReached && state.x < -220) {
                state.score++;
                els.score.textContent = state.score;
                els.token.classList.add("success");
                state.paused = true;
                setTimeout(() => {
                    state.paused = false;
                    pickToken();
                    resetTokenPosition();
                }, 400);
            }
        }
        requestAnimationFrame(animate);
    }

    // --- INPUTS ---
    document.addEventListener("keydown", e => {
        if(e.key === "ArrowUp") moveLane(-1);
        if(e.key === "ArrowDown") moveLane(1);
    });
    
    document.getElementById("move-up").onclick = () => moveLane(-1);
    document.getElementById("move-down").onclick = () => moveLane(1);
    
    document.getElementById("speed").oninput = (e) => state.speed = parseInt(e.target.value);

    els.startBtn.onclick = () => {
        if(state.data.length === 0) return;
        state.lives = parseInt(document.getElementById("lives").value);
        state.score = 0;
        els.lives.textContent = state.lives;
        els.score.textContent = 0;
        state.isRunning = true;
        state.paused = false;
        state.lastTime = null;
        els.startBtn.disabled = true;
        
        pickToken();
        resetTokenPosition();
        requestAnimationFrame(animate);
    };

    window.onresize = () => {
        resizeGates();
        if(state.token) positionToken();
    };

    // Load Data
    initLanes();
    resizeGates();
    
    fetch(DATA_PATH).then(r => r.json()).then(data => {
        state.data = buildVerbEntries(data);
        els.msg.textContent = `Loaded ${state.data.length} verbs. Ready.`;
    }).catch(e => {
        console.warn("Using mock data");
        const mock = [];
        for(let i=0; i<18; i++) mock.push({french: "mange (mock)"});
        state.data = buildVerbEntries(mock);
        els.msg.textContent = "Loaded mock data.";
    });

  </script>
</body>
</html>
