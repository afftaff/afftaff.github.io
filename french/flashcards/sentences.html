<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>French Flip Flashcards</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #4f46e5;
      --bg: #f3f4f6;
      --card-bg: #ffffff;
      --text-main: #1f2937;
      --text-muted: #6b7280;
      --border: #e5e7eb;
      --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    body {
      background-color: var(--bg);
      font-family: 'Inter', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      color: var(--text-main);
    }

    /* --- Controls UI --- */
    .controls-container {
      width: 100%;
      max-width: 800px;
      margin-bottom: 30px;
      background: white;
      padding: 15px;
      border-radius: 12px;
      box-shadow: var(--shadow);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      z-index: 10; /* Ensure controls are above scene */
      position: relative;
    }

    .nav-group {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    button.nav-btn {
      background: white;
      border: 1px solid var(--border);
      padding: 8px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    button.nav-btn:hover { background: #f9fafb; border-color: var(--primary); color: var(--primary); }

    .status-badge {
      background: #e0e7ff;
      color: var(--primary);
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    /* --- MAIN CARD SCENE --- */
    .scene {
      width: 100%;
      max-width: 700px;
      /* Remove fixed height, let it be determined by the card */
      min-height: 400px; 
      perspective: 1500px;
      margin: 0 auto 50px auto;
      position: relative;
    }

    .main-card {
      width: 100%;
      /* Default Height (Front) */
      height: 400px; 
      position: relative;
      transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275), height 0.6s ease;
      transform-style: preserve-3d;
      cursor: pointer;
    }

    /* Class applied via JS to flip */
    .main-card.is-flipped {
      transform: rotateY(180deg);
      /* Expanded Height (Back) */
      height: 700px; 
    }

    .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden; /* Safari fix */
      backface-visibility: hidden;
      border-radius: 20px;
      background: var(--card-bg);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border);
      overflow: hidden;
    }

    /* --- Main Card FRONT --- */
    .card-face.front {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2; /* Initially on top */
      background-color: white; /* Ensure non-transparent */
    }

    /* When flipped, hide front explicitly via z-index change to prevent bleed-through */
    .main-card.is-flipped .card-face.front {
      z-index: 0;
    }

    .big-speaker {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4f46e5, #818cf8);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      box-shadow: 0 10px 30px rgba(79, 70, 229, 0.4);
      cursor: pointer;
      transition: transform 0.2s;
      margin-bottom: 2rem;
      /* Ensure speaker doesn't have its own 3d context causing issues */
      transform: translateZ(1px); 
    }
    .big-speaker:hover { transform: scale(1.05) translateZ(1px); }
    .big-speaker:active { transform: scale(0.95) translateZ(1px); }

    .hint-text { color: var(--text-muted); font-size: 0.9rem; margin-top: 20px; }

    /* --- Main Card BACK --- */
    .card-face.back {
      transform: rotateY(180deg);
      display: flex;
      flex-direction: column;
      background-color: white; /* Ensure non-transparent */
      z-index: 1;
    }
    
    /* When flipped, promote back face */
    .main-card.is-flipped .card-face.back {
      z-index: 10;
    }

    .back-content-scroll {
      flex: 1;
      overflow-y: auto;
      padding: 25px;
    }

    /* Sentence Strips */
    .strip {
      width: 100%;
      padding: 12px 16px;
      background: #f8fafc;
      border-left: 4px solid var(--primary);
      margin-bottom: 12px;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .strip-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 4px;
      display: block;
    }
    .strip-text {
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--text-main);
      line-height: 1.4;
    }
    .strip-text.main-sentence { font-size: 1.25rem; font-weight: 700; color: var(--primary); }

    .divider {
      height: 1px;
      background: var(--border);
      margin: 20px 0;
      width: 100%;
    }

    /* --- MINI CARDS GRID --- */
    .mini-cards-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      padding-bottom: 20px;
    }

    .mini-card-scene {
      width: 100%;
      height: 160px;
      perspective: 800px;
    }

    .mini-card {
      width: 100%;
      height: 100%;
      position: relative;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      cursor: pointer;
    }

    .mini-card.is-flipped {
      transform: rotateY(180deg);
    }

    .mini-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: white;
      display: flex;
      flex-direction: column;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
      overflow: hidden;
    }

    .mini-face.front {
      align-items: center;
      justify-content: center;
      gap: 15px;
      background: #fafafa;
    }

    .mini-speaker {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: white;
      border: 1px solid var(--border);
      color: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .mini-speaker:hover { background: #e0e7ff; }

    .mini-word-front {
      font-size: 1.2rem;
      font-weight: 700;
      color: var(--text-main);
    }

    .mini-face.back {
      transform: rotateY(180deg);
      display: flex;
      flex-direction: column;
      background: #fff;
    }

    .mini-info-grid {
      display: flex;
      flex-wrap: wrap;
      height: 100%;
    }

    .mini-cell {
      padding: 10px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      border-bottom: 1px solid var(--border);
    }

    .mini-cell label {
      font-size: 0.65rem;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 2px;
    }
    .mini-cell span {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-main);
    }

    .mini-cell.half { width: 50%; border-right: 1px solid var(--border); }
    .mini-cell.half:last-child { border-right: none; }
    .mini-cell.full { width: 100%; background: #fdfdfd; flex: 1; border-bottom: none; }

  </style>
</head>
<body>

  <!-- Controls -->
  <div class="controls-container">
    <div class="nav-group">
      <button class="nav-btn" onclick="prevDeck()">Prev Deck</button>
      <span class="status-badge" id="deckLabel">Deck 1</span>
      <button class="nav-btn" onclick="nextDeck()">Next Deck</button>
    </div>
    <div class="nav-group">
      <button class="nav-btn" onclick="prevCard()">Prev Card</button>
      <span class="status-badge" id="cardLabel">Card 1 / 50</span>
      <button class="nav-btn" onclick="nextCard()">Next Card</button>
    </div>
  </div>

  <!-- The 3D Scene -->
  <div class="scene">
    <div class="main-card" id="mainCard">
      
      <!-- Front of Main Card -->
      <div class="card-face front">
        <div class="big-speaker" id="mainSpeaker">üîä</div>
        <h2>Click card to flip</h2>
        <p class="hint-text">Listen first, then flip to reveal breakdown</p>
      </div>

      <!-- Back of Main Card -->
      <div class="card-face back">
        <div class="back-content-scroll">
          
          <div class="strip">
            <span class="strip-label">Sentence</span>
            <div class="strip-text main-sentence" id="txtSentence">Chargement...</div>
          </div>

          <div class="strip">
            <span class="strip-label">Meaning</span>
            <div class="strip-text" id="txtMeaning">...</div>
          </div>

          <div class="strip">
            <span class="strip-label">Translation</span>
            <div class="strip-text" id="txtTranslation">...</div>
          </div>

          <div class="divider"></div>

          <div id="miniCardsArea" class="mini-cards-container">
            <!-- JS inserts mini cards here -->
          </div>

        </div>
      </div>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // --- State Management ---
    const state = {
      decks: [],
      currentDeckIndex: 0,
      currentCardIndex: 0
    };

    const els = {
      mainCard: document.getElementById('mainCard'),
      mainSpeaker: document.getElementById('mainSpeaker'),
      deckLabel: document.getElementById('deckLabel'),
      cardLabel: document.getElementById('cardLabel'),
      txtSentence: document.getElementById('txtSentence'),
      txtMeaning: document.getElementById('txtMeaning'),
      txtTranslation: document.getElementById('txtTranslation'),
      miniCardsArea: document.getElementById('miniCardsArea')
    };

    // --- Interaction Logic ---

    // Flip Main Card
    els.mainCard.addEventListener('click', (e) => {
      // 1. Don't flip if clicking inside a mini-card
      if (e.target.closest('.mini-card')) return;

      // 2. DISABLE FLIP BACK: If already flipped, do not toggle back to front
      if (els.mainCard.classList.contains('is-flipped')) {
        return; 
      }

      // 3. Flip and Expand
      els.mainCard.classList.add('is-flipped');
    });

    // Main Speaker
    els.mainSpeaker.addEventListener('click', (e) => {
      e.stopPropagation();
      playCurrentAudio();
    });

    function playCurrentAudio() {
      const card = getCurrentCard();
      if(card) speak(card.Sentence);
    }

    function speak(text) {
      if (!text) return;
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = 'fr-FR';
      utter.rate = 0.9;
      window.speechSynthesis.speak(utter);
    }

    // --- Rendering Logic ---

    function render() {
      const card = getCurrentCard();
      if (!card) return;

      // Reset Flip State when changing cards (Back to small size, front face)
      els.mainCard.classList.remove('is-flipped');

      // Update Header Text
      els.deckLabel.textContent = `Deck ${state.currentDeckIndex + 1}`;
      els.cardLabel.textContent = `Card ${state.currentCardIndex + 1} / ${state.decks[state.currentDeckIndex].length}`;

      // Update Main Back Content
      els.txtSentence.textContent = card.Sentence;
      els.txtMeaning.textContent = card.Meaning || "No meaning provided";
      els.txtTranslation.textContent = card.Sentence_Translation || "No translation provided";

      // Render Mini Cards
      renderMiniCards(card.Sentence_Breakdown, card.Sentence);
    }

    function renderMiniCards(breakdownStr, sentenceText) {
      els.miniCardsArea.innerHTML = '';
      const words = parseBreakdown(breakdownStr, sentenceText);

      words.forEach(word => {
        const scene = document.createElement('div');
        scene.className = 'mini-card-scene';

        const card = document.createElement('div');
        card.className = 'mini-card';
        
        card.addEventListener('click', (e) => {
          e.stopPropagation();
          card.classList.toggle('is-flipped');
        });

        const front = document.createElement('div');
        front.className = 'mini-face front';
        
        const spk = document.createElement('button');
        spk.className = 'mini-speaker';
        spk.textContent = 'üîä';
        spk.onclick = (e) => {
          e.stopPropagation();
          speak(word.base || word.rawWord);
        };

        const wordLabel = document.createElement('div');
        wordLabel.className = 'mini-word-front';
        wordLabel.textContent = word.base || word.rawWord;

        front.appendChild(spk);
        front.appendChild(wordLabel);

        const back = document.createElement('div');
        back.className = 'mini-face back';

        back.innerHTML = `
          <div class="mini-info-grid">
            <div class="mini-cell half">
              <label>Meaning</label>
              <span>${word.meaning || '-'}</span>
            </div>
            <div class="mini-cell half">
              <label>Pronunciation</label>
              <span>${word.ipa || '-'}</span>
            </div>
            <div class="mini-cell full">
              <label>Part of Speech / Notes</label>
              <span>${word.pos || word.elision || '-'}</span>
            </div>
          </div>
        `;

        card.appendChild(front);
        card.appendChild(back);
        scene.appendChild(card);
        els.miniCardsArea.appendChild(scene);
      });
    }

    // --- Helpers ---

    function getCurrentCard() {
      if (state.decks.length === 0) return null;
      return state.decks[state.currentDeckIndex][state.currentCardIndex];
    }

    function parseBreakdown(text, sentenceText) {
      const hasBreakdown = text && text.trim().length > 0;

      if (!hasBreakdown && sentenceText) {
        return (sentenceText.match(/[^\s]+/g) || []).map(word => {
          const cleaned = word.replace(/[.,!?;:]+$/g, '');
          return { rawWord: cleaned, base: cleaned };
        });
      }

      if (!hasBreakdown) return [];

      return text.split(';').map(part => {
        const p = part.split('|');
        const rawWord = p[0] ? p[0].trim() : '';
        const base = rawWord ? rawWord.replace(/\(.*\)/, '').trim() : '';
        return {
          rawWord,
          meaning: p[1] || '',
          pos: p[2] || '',
          ipa: p[3] || '',
          elision: p[4] || '',
          base
        };
      }).filter(w => w.rawWord);
    }

    function chunk(arr, size) {
      const groups = [];
      for (let i = 0; i < arr.length; i += size) groups.push(arr.slice(i, i + size));
      return groups;
    }

    function shuffle(arr) {
      return arr.sort(() => Math.random() - 0.5);
    }

    // --- Navigation ---
    window.nextDeck = () => {
      state.currentDeckIndex = (state.currentDeckIndex + 1) % state.decks.length;
      state.currentCardIndex = 0;
      render();
    };
    window.prevDeck = () => {
      state.currentDeckIndex = (state.currentDeckIndex - 1 + state.decks.length) % state.decks.length;
      state.currentCardIndex = 0;
      render();
    };
    window.nextCard = () => {
      if(state.decks.length === 0) return;
      const len = state.decks[state.currentDeckIndex].length;
      state.currentCardIndex = (state.currentCardIndex + 1) % len;
      render();
    };
    window.prevCard = () => {
      if(state.decks.length === 0) return;
      const len = state.decks[state.currentDeckIndex].length;
      state.currentCardIndex = (state.currentCardIndex - 1 + len) % len;
      render();
    };

    // --- Initialization ---
    function boot() {
      // Mock Data for demonstration since I don't have your CSV
      // If you are using a local CSV, replace the data below with your Papa.parse call
      const mockData = [
        {
          Sentence: "Il pr√©f√®re √©crire une lettre plut√¥t que t√©l√©phoner.",
          Meaning: "to write",
          Sentence_Translation: "He prefers to write a letter rather than phone.",
          Sentence_Breakdown: "Il|He|Pronoun|il|; pr√©f√®re|prefers|Verb|p Åe.f…õ Å|; √©crire|to write|Verb|e.k Åi Å|; une|a|Article|yn|; lettre|letter|Noun|l…õt Å|; plut√¥t|rather|Adverb|ply.to|; que|than|Conjunction|k…ô|; t√©l√©phoner|to phone|Verb|te.le.f…î.ne|"
        },
         {
          Sentence: "Bonjour tout le monde.",
          Meaning: "Hello everyone",
          Sentence_Translation: "Hello everyone.",
          Sentence_Breakdown: "Bonjour|Hello|Noun|b…îÃÉ. íu Å|; tout|all|Adjective|tu|; le|the|Article|l…ô|; monde|world|Noun|m…îÃÉd|"
        }
      ];

      state.decks = chunk(mockData, 50);
      render();
    }

    boot();

  </script>
</body>
</html>
