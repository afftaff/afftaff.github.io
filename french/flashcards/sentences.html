<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>French Flip Flashcards</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #4f46e5;
      --primary-light: #e0e7ff;
      --bg: #f3f4f6;
      --card-bg: #ffffff;
      --text-main: #1f2937;
      --text-muted: #6b7280;
      --border: #e5e7eb;
      --shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    body {
      background-color: var(--bg);
      font-family: 'Inter', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      color: var(--text-main);
    }

    /* --- Controls UI --- */
    .controls-container {
      width: 100%;
      max-width: 800px;
      margin-bottom: 25px;
      background: white;
      padding: 15px;
      border-radius: 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 12px;
      z-index: 10;
      position: relative;
      box-sizing: border-box;
    }

    .nav-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      gap: 12px;
    }

    button.nav-btn {
      flex: 0 0 90px;
      height: 52px;
      background: white;
      border: 1px solid var(--border);
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1.2rem;
      color: var(--text-muted);
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    button.nav-btn:hover { background: #f9fafb; border-color: var(--primary); color: var(--primary); }
    button.nav-btn:active { background: var(--primary-light); transform: scale(0.96); }

    .status-badge {
      flex: 1;
      background: var(--primary-light);
      color: var(--primary);
      height: 52px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.95rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      user-select: none;
    }

    /* --- MAIN CARD SCENE --- */
    .scene {
      width: 100%;
      max-width: 800px;
      min-height: 400px; 
      perspective: 1500px;
      margin: 0 auto 50px auto;
      position: relative;
    }

    .main-card {
      width: 100%;
      height: 400px; 
      position: relative;
      transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275), height 0.6s ease;
      transform-style: preserve-3d;
      cursor: pointer;
    }

    .main-card.is-flipped {
      transform: rotateY(180deg);
      height: 1050px; 
    }

    .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      border-radius: 24px;
      background: var(--card-bg);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
      border: 1px solid var(--border);
      overflow: hidden;
    }

    /* --- Main Card FRONT --- */
    .card-face.front {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 2;
      background-color: white;
    }

    .main-card.is-flipped .card-face.front { z-index: 0; }

    .big-speaker {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4f46e5, #818cf8);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 3rem;
      box-shadow: 0 10px 30px rgba(79, 70, 229, 0.4);
      cursor: pointer;
      transition: transform 0.2s;
      margin-bottom: 2rem;
      transform: translateZ(1px); 
    }
    .big-speaker:hover { transform: scale(1.05) translateZ(1px); }

    .hint-text { color: var(--text-muted); font-size: 0.9rem; margin-top: 20px; text-align: center; padding: 0 20px;}

    /* --- Main Card BACK --- */
    .card-face.back {
      transform: rotateY(180deg);
      display: flex;
      flex-direction: column;
      background-color: white;
      z-index: 1;
    }
    
    .main-card.is-flipped .card-face.back { z-index: 10; }

    .back-content-scroll {
      flex: 1;
      overflow-y: auto;
      padding: 25px;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      gap: 15px;
    }

    /* --- TOP SECTION (Info Chips) --- */
    .info-group {
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex-shrink: 0; 
    }

    .info-chip {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-left: 6px solid var(--primary);
      border-radius: 14px;
      padding: 22px 24px;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .info-chip:hover { 
      background: #eff6ff; 
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0,0,0,0.02);
    }
    
    .info-label {
      font-size: 0.85rem; 
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      font-weight: 800;
    }
    
    .info-content {
      display: none; 
      margin-top: 8px;
      font-size: 1.25rem; 
      font-weight: 500;
      color: var(--text-main);
      line-height: 1.4;
    }
    .info-content.highlight { color: var(--primary); font-weight: 700; }
    
    .info-chip.is-revealed .info-label { display: none; }
    .info-chip.is-revealed .info-content { display: block; animation: fadeIn 0.3s ease; }

    /* --- CAROUSEL SECTION --- */
    .carousel-section {
      margin-top: 5px;
      padding-top: 15px;
      border-top: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center; 
      width: 100%;
      gap: 15px; /* Spacing between controls and card */
    }

    /* New Wrapper for [Arrow] [Counter] [Arrow] */
    .carousel-controls {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
      gap: 12px;
    }

    .word-counter {
      text-align: center;
      font-size: 1.1rem;
      font-weight: 700;
      color: var(--primary);
      background: var(--primary-light);
      padding: 0 20px;
      height: 52px; /* Same height as buttons */
      border-radius: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1; /* Take up remaining space */
    }

    .arrow-btn {
      background: white;
      border: 1px solid var(--border);
      width: 56px; 
      height: 52px; /* Match counter height */
      flex-shrink: 0;
      border-radius: 12px; /* Square-ish with rounded corners */
      font-size: 1.5rem;
      color: var(--text-muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      z-index: 5;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    }
    .arrow-btn:hover { background: #f9fafb; color: var(--primary); border-color: var(--primary); }
    .arrow-btn:active { background: #eff6ff; transform: scale(0.95); }
    .arrow-btn:disabled { opacity: 0.3; cursor: not-allowed; border-color: var(--border); color: var(--text-muted); }

    .word-scene {
      width: 100%; /* FULL WIDTH */
      height: 500px; 
      perspective: 1000px;
      position: relative;
      overflow: hidden; 
    }

    /* Single Word Card */
    .mini-card {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      transform-style: preserve-3d;
      cursor: pointer;
    }
    .mini-card.is-flipped { transform: rotateY(180deg); }

    .mini-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 20px;
      border: 1px solid var(--border);
      background: white;
      display: flex;
      flex-direction: column;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      overflow: hidden;
      box-sizing: border-box;
    }

    /* Front: Huge Speaker */
    .mini-face.front {
      align-items: center;
      justify-content: center;
      background: #fafafa;
    }
    .mini-speaker-large {
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: linear-gradient(135deg, #4f46e5, #818cf8);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 5rem;
      cursor: pointer;
      border: none;
      box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
      transition: transform 0.2s;
    }
    .mini-speaker-large:hover { transform: scale(1.05); }

    /* Back: Content */
    .mini-face.back {
      transform: rotateY(180deg);
      padding: 20px;
      background: white;
    }

    .mini-back-header {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
      height: 64px; 
    }

    .mini-speaker-small {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: #f3f4f6;
      border: 1px solid var(--border);
      color: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    .mini-speaker-small:hover { background: #e0e7ff; transform: scale(1.05); }

    .mini-chips-stack {
      display: flex;
      flex-direction: column;
      gap: 12px;
      flex: 1;
      justify-content: center;
    }

    .chip-row {
      display: flex;
      gap: 10px;
      width: 100%;
    }

    .chip {
      background: #f3f4f6;
      border-radius: 12px;
      flex: 1;
      padding: 12px;
      text-align: center;
      cursor: pointer;
      min-height: 72px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border: 1px solid transparent;
      transition: all 0.2s;
    }
    .chip:hover { border-color: var(--primary); }
    .chip.is-base { background: #fed7aa; border-color: #fdba74; }
    .chip.is-article { background: #bfdbfe; border-color: #93c5fd; }
    .chip.is-revealed { background: #e0e7ff; border-color: #c7d2fe; }

    .chip-lbl { font-size: 0.8rem; font-weight: 700; text-transform: uppercase; color: var(--text-muted); letter-spacing: 0.05em; }
    
    .chip-val { display: none; color: var(--text-main); word-break: break-word; line-height: 1.3; }
    
    .chip-val.text-xl { font-size: 2.2rem; font-weight: 800; color: var(--primary); }
    .chip-val.text-lg { font-size: 1.4rem; font-weight: 600; }
    .chip-val.text-md { font-size: 1.1rem; font-weight: 500; }

    .chip.is-revealed .chip-lbl { display: none; }
    .chip.is-revealed .chip-val { display: block; }

    .chip-hint {
      display: none;
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 4px;
      line-height: 1.2;
    }

    .chip.is-base .chip-hint { display: block; }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  </style>
</head>
<body>

  <!-- Controls -->
  <div class="controls-container">
    <div class="nav-row">
      <button class="nav-btn" onclick="prevDeck()">&#10094;</button>
      <div class="status-badge" id="deckLabel">Deck 1</div>
      <button class="nav-btn" onclick="nextDeck()">&#10095;</button>
    </div>
    <div class="nav-row">
      <button class="nav-btn" onclick="prevCard()">&#10094;</button>
      <div class="status-badge" id="cardLabel">Card 1 / 50</div>
      <button class="nav-btn" onclick="nextCard()">&#10095;</button>
    </div>
  </div>

  <!-- The 3D Scene -->
  <div class="scene">
    <div class="main-card" id="mainCard">
      
      <!-- Front of Main Card -->
      <div class="card-face front">
        <div class="big-speaker" id="mainSpeaker">ðŸ”Š</div>
        <h2>Click card to flip</h2>
        <p class="hint-text">Listen first, then flip to reveal breakdown</p>
      </div>

      <!-- Back of Main Card -->
      <div class="card-face back">
        <div class="back-content-scroll">
          
          <div class="info-group">
            <div class="info-chip" onclick="toggleInfo(this)">
              <span class="info-label">Sentence</span>
              <div class="info-content highlight" id="txtSentence">...</div>
            </div>
            <div class="info-chip" onclick="toggleInfo(this)">
              <span class="info-label">Meaning</span>
              <div class="info-content" id="txtMeaning">...</div>
            </div>
            <div class="info-chip" onclick="toggleInfo(this)">
              <span class="info-label">Translation</span>
              <div class="info-content" id="txtTranslation">...</div>
            </div>
          </div>

          <div class="carousel-section">
            
            <!-- Controls Row: [ < ] [ Counter ] [ > ] -->
            <div class="carousel-controls">
              <button class="arrow-btn" id="btnPrevWord" onclick="navWord(-1)">&#10094;</button>
              <div id="wordCounter" class="word-counter">Word 1 / 5</div>
              <button class="arrow-btn" id="btnNextWord" onclick="navWord(1)">&#10095;</button>
            </div>

            <!-- Full Width Card Scene -->
            <div class="word-scene" id="wordCardContainer">
              <!-- JS inserts the single active word card here -->
            </div>

          </div>

        </div>
      </div>

    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // --- State Management ---
    const state = {
      decks: [],
      currentDeckIndex: 0,
      currentCardIndex: 0,
      currentWordIndex: 0,
      currentWordsList: [] 
    };

    const els = {
      mainCard: document.getElementById('mainCard'),
      mainSpeaker: document.getElementById('mainSpeaker'),
      deckLabel: document.getElementById('deckLabel'),
      cardLabel: document.getElementById('cardLabel'),
      txtSentence: document.getElementById('txtSentence'),
      txtMeaning: document.getElementById('txtMeaning'),
      txtTranslation: document.getElementById('txtTranslation'),
      wordCardContainer: document.getElementById('wordCardContainer'),
      btnPrevWord: document.getElementById('btnPrevWord'),
      btnNextWord: document.getElementById('btnNextWord'),
      wordCounter: document.getElementById('wordCounter')
    };

    // --- Interaction Logic ---

    window.toggleInfo = (el) => {
      event.stopPropagation();
      el.classList.toggle('is-revealed');
    };

    els.mainCard.addEventListener('click', (e) => {
      if (e.target.closest('.info-chip') || 
          e.target.closest('.carousel-controls') || 
          e.target.closest('button')) return;

      if (els.mainCard.classList.contains('is-flipped')) return; 
      els.mainCard.classList.add('is-flipped');
    });

    els.mainSpeaker.addEventListener('click', (e) => {
      e.stopPropagation();
      playCurrentAudio();
    });

    function playCurrentAudio() {
      const card = getCurrentCard();
      if(card) speak(card.Sentence);
    }

    function speak(text) {
      if (!text) return;
      window.speechSynthesis.cancel();
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = 'fr-FR';
      utter.rate = 0.9;
      window.speechSynthesis.speak(utter);
    }

    // --- Word Navigation (Sliding) ---
    window.navWord = (dir) => {
      event.stopPropagation();
      const newIndex = state.currentWordIndex + dir;
      if (newIndex >= 0 && newIndex < state.currentWordsList.length) {
        transitionToWord(dir);
      }
    };

    // --- Transition Logic ---
    function transitionToWord(dir) {
      const oldCard = els.wordCardContainer.querySelector('.mini-card');
      
      state.currentWordIndex += dir;
      const index = state.currentWordIndex;
      const total = state.currentWordsList.length;
      const word = state.currentWordsList[index];

      // Update UI
      els.wordCounter.textContent = total > 0 ? `Word ${index + 1} / ${total}` : '';
      els.btnPrevWord.disabled = (index === 0);
      els.btnNextWord.disabled = (index === total - 1);

      const newCard = createWordCardElement(word);

      // Initial Load
      if (dir === 0 || !oldCard) {
        els.wordCardContainer.innerHTML = '';
        els.wordCardContainer.appendChild(newCard);
        return;
      }

      // Slide Animation
      newCard.style.transition = 'none'; 
      const startX = dir > 0 ? '100%' : '-100%';
      newCard.style.transform = `translateX(${startX})`;
      els.wordCardContainer.appendChild(newCard);

      void newCard.offsetWidth; // Force Reflow

      const duration = 300;
      const ease = 'ease-in-out';

      oldCard.style.transition = `transform ${duration}ms ${ease}`;
      const oldIsFlipped = oldCard.classList.contains('is-flipped');
      const endX = dir > 0 ? '-100%' : '100%'; 
      oldCard.style.transform = `translateX(${endX}) ${oldIsFlipped ? 'rotateY(180deg)' : ''}`;

      newCard.style.transition = `transform ${duration}ms ${ease}`;
      newCard.style.transform = 'translateX(0)';

      setTimeout(() => {
        if(oldCard.parentNode === els.wordCardContainer) {
          els.wordCardContainer.removeChild(oldCard);
        }
        // FIX: Clear the inline style so the click-flip animation works again
        newCard.style.transition = ''; 
        newCard.style.transform = ''; 
      }, duration);
    }

    function createWordCardElement(word) {
      if (!word) {
        const div = document.createElement('div');
        div.className = 'mini-card';
        div.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#ccc">No Data</div>';
        return div;
      }

      const cardEl = document.createElement('div');
      cardEl.className = 'mini-card';
      
      cardEl.addEventListener('click', (e) => {
        e.stopPropagation();
        cardEl.classList.toggle('is-flipped');
      });

      // Front
      const front = document.createElement('div');
      front.className = 'mini-face front';
      front.innerHTML = `<button class="mini-speaker-large">ðŸ”Š</button>`;
      front.querySelector('button').onclick = (e) => {
        e.stopPropagation();
        speak(word.base || word.rawWord);
      };

      // Back
      const back = document.createElement('div');
      back.className = 'mini-face back';

      const createChip = (lbl, val, sizeClass, options = {}) => {
        const chip = document.createElement('div');
        chip.className = 'chip';

        const labelSpan = document.createElement('span');
        labelSpan.className = 'chip-lbl';
        labelSpan.textContent = lbl;

        const valueSpan = document.createElement('span');
        valueSpan.className = `chip-val ${sizeClass}`;
        valueSpan.textContent = val || '-';

        const hintSpan = document.createElement('span');
        hintSpan.className = 'chip-hint';
        hintSpan.textContent = 'Click again to show article + noun';

        chip.appendChild(labelSpan);
        chip.appendChild(valueSpan);
        if (options.chipType === 'word') {
          chip.appendChild(hintSpan);
        }

        const baseValue = val || '-';
        const article = options.article?.trim();
        const articleSupported = /^l[ae]\b/i.test(article || '');
        const hasArticle = !!articleSupported && options.chipType === 'word';

        chip.addEventListener('click', (event) => {
          event.stopPropagation();

          if (hasArticle) {
            const stage = chip.dataset.stage;

            // Stage 1: reveal noun only with orange background + hint
            if (!stage || stage === 'hidden') {
              chip.dataset.stage = 'base';
              chip.classList.add('is-revealed', 'is-base');
              chip.classList.remove('is-article');
              valueSpan.textContent = baseValue;
              hintSpan.style.display = '';
              return;
            }

            // Stage 2: show article + noun with blue background
            if (stage === 'base') {
              chip.dataset.stage = 'article';
              chip.classList.remove('is-base');
              chip.classList.add('is-article');
              valueSpan.textContent = `${article} ${baseValue}`;
              hintSpan.style.display = 'none';
              return;
            }

            // Stage 3: toggle back to noun-only view
            chip.dataset.stage = 'base';
            chip.classList.add('is-base');
            chip.classList.remove('is-article');
            valueSpan.textContent = baseValue;
            hintSpan.style.display = '';
            return;
          }

          chip.classList.toggle('is-revealed');
        });

        return chip;
      };

      const header = document.createElement('div');
      header.className = 'mini-back-header';
      const backSpeaker = document.createElement('button');
      backSpeaker.className = 'mini-speaker-small';
      backSpeaker.textContent = 'ðŸ”Š';
      backSpeaker.onclick = (event) => {
        event.stopPropagation();
        speak(word.base || word.rawWord);
      };
      header.appendChild(backSpeaker);

      const chipsStack = document.createElement('div');
      chipsStack.className = 'mini-chips-stack';

      const rowWord = document.createElement('div');
      rowWord.className = 'chip-row';
      rowWord.appendChild(createChip('Word', word.base || word.rawWord, 'text-xl', { article: word.article, chipType: 'word' }));

      const rowMeaning = document.createElement('div');
      rowMeaning.className = 'chip-row';
      rowMeaning.appendChild(createChip('Meaning', word.meaning, 'text-lg'));

      const rowDetails = document.createElement('div');
      rowDetails.className = 'chip-row';
      rowDetails.appendChild(createChip('IPA', word.ipa, 'text-md'));
      rowDetails.appendChild(createChip('Type', word.pos, 'text-md'));

      chipsStack.appendChild(rowWord);
      chipsStack.appendChild(rowMeaning);
      chipsStack.appendChild(rowDetails);

      back.appendChild(header);
      back.appendChild(chipsStack);

      cardEl.appendChild(front);
      cardEl.appendChild(back);
      return cardEl;
    }

    // --- Rendering Logic ---

    function render() {
      const card = getCurrentCard();
      if (!card) return;

      els.mainCard.classList.remove('is-flipped');
      document.querySelectorAll('.info-chip').forEach(el => el.classList.remove('is-revealed'));

      els.deckLabel.textContent = `Deck ${state.currentDeckIndex + 1}`;
      els.cardLabel.textContent = `Card ${state.currentCardIndex + 1} / ${state.decks[state.currentDeckIndex].length}`;

      els.txtSentence.innerHTML = `${card.Sentence} <span style="font-size:1.2rem; margin-left:10px; cursor:pointer" onclick="event.stopPropagation(); speak('${card.Sentence.replace(/'/g, "\\'")}')">ðŸ”Š</span>`;
      els.txtMeaning.textContent = card.Meaning || "-";
      els.txtTranslation.textContent = card.Sentence_Translation || "-";

      state.currentWordsList = parseBreakdown(card.Sentence_Breakdown, card.Sentence);
      state.currentWordIndex = 0;
      transitionToWord(0); 
    }

    // --- Data Helpers ---

    function getCurrentCard() {
      if (state.decks.length === 0) return null;
      return state.decks[state.currentDeckIndex][state.currentCardIndex];
    }

    function parseBreakdown(text, sentenceText) {
      const hasBreakdown = text && text.trim().length > 0;
      if (!hasBreakdown && sentenceText) {
        return (sentenceText.match(/[^\s]+/g) || []).map(word => {
          const cleaned = word.replace(/[.,!?;:]+$/g, '');
          return { rawWord: cleaned, base: cleaned };
        });
      }
      if (!hasBreakdown) return [];
      return text.split(';').map(part => {
        const p = part.split('|');
        const rawWord = p[0] ? p[0].trim() : '';
        const base = rawWord ? rawWord.replace(/\(.*\)/, '').trim() : '';
        const articleMatch = rawWord.match(/\(([^)]+)\)/);
        const article = articleMatch ? articleMatch[1].trim() : '';
        return {
          rawWord, meaning: p[1]||'', pos: p[2]||'', ipa: p[3]||'', elision: p[4]||'', base, article
        };
      }).filter(w => w.rawWord);
    }

    function chunk(arr, size) {
      const res = [];
      for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
      return res;
    }

    function shuffle(arr) {
      return arr.sort(() => Math.random() - 0.5);
    }

    function parseCSVLine(line) {
      const values = [];
      let current = '';
      let inQuotes = false;

      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const next = line[i + 1];

        if (char === '"') {
          if (inQuotes && next === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          values.push(current);
          current = '';
        } else {
          current += char;
        }
      }

      values.push(current);
      return values.map(v => v.trim());
    }

    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      if (lines.length === 0) return [];

      const headers = parseCSVLine(lines.shift());
      return lines.map(line => {
        const cols = parseCSVLine(line);
        const row = {};
        headers.forEach((h, idx) => { row[h] = cols[idx] || ''; });
        return row;
      });
    }

    window.nextDeck = () => { state.currentDeckIndex = (state.currentDeckIndex + 1) % state.decks.length; state.currentCardIndex=0; render(); };
    window.prevDeck = () => { state.currentDeckIndex = (state.currentDeckIndex - 1 + state.decks.length) % state.decks.length; state.currentCardIndex=0; render(); };
    window.nextCard = () => { if(state.decks.length) { state.currentCardIndex = (state.currentCardIndex + 1) % state.decks[state.currentDeckIndex].length; render(); }};
    window.prevCard = () => { if(state.decks.length) { const len = state.decks[state.currentDeckIndex].length; state.currentCardIndex = (state.currentCardIndex - 1 + len) % len; render(); }};

    async function boot() {
      try {
        const response = await fetch('/french/dir/words/sentences.csv');
        const text = await response.text();
        const rows = parseCSV(text);

        const cards = rows.map(row => ({
          Sentence: row.Sentence,
          Meaning: row.Meaning,
          Sentence_Translation: row.Sentence_Translation,
          Sentence_Breakdown: row.Sentence_Breakdown
        })).filter(card => card.Sentence);

        state.decks = chunk(cards, 50);
        state.currentDeckIndex = 0;
        state.currentCardIndex = 0;
        render();
      } catch (err) {
        console.error('Failed to load sentences.csv', err);
      }
    }
    boot();

  </script>
</body>
</html>
