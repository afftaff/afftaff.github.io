<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>French Reader</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f7f6f3;
      --paper: #ffffff;
      --text: #2c3e50;
      --muted: #7f8c8d;
      --border: #e0ded8;
      --highlight-sentence: #e3e8ef; /* Light blue-grey for sentence hover */
      --highlight-word: #cbd5e1;     /* Darker grey for word hover */
      --success-bg: #dcfce7;         /* Light green for learnt sentences */
      --success-border: #86efac;
      --accent: #2c3e50;
      --radius: 12px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
      --font-read: 'Inter', sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--font-read);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      background: var(--paper);
      border-bottom: 1px solid var(--border);
      padding: 1rem 1.5rem;
      position: sticky;
      top: 0;
      z-index: 50;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.03);
    }
    header h1 { margin: 0; font-size: 1.1rem; font-weight: 700; color: var(--accent); }
    header .stats { font-size: 0.85rem; color: var(--muted); }

    /* Main Container */
    main {
      flex: 1;
      width: 100%;
      max-width: 800px; /* Blog post width */
      margin: 0 auto;
      padding: 2rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    /* Reader View */
    .reader-container {
      background: var(--paper);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 3rem;
      min-height: 200px;
      line-height: 1.8;
      font-size: 1.125rem; /* 18px for better reading */
    }

    @media (max-width: 600px) {
      .reader-container { padding: 1.5rem; font-size: 1rem; }
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      padding: 2rem;
      font-style: italic;
    }

    /* Text Interaction Styles */
    .sentence-wrap {
      padding: 0.15rem 0.2rem;
      border-radius: 6px;
      transition: background 0.1s ease;
      cursor: pointer;
      margin-right: 4px; /* Space between sentences */
    }

    /* Learned State */
    .sentence-wrap.learned {
      background-color: var(--success-bg);
      box-shadow: 0 0 0 1px var(--success-border);
    }

    /* Hover States - Logic: Highlight sentence light, Highlight word dark */
    .sentence-wrap:hover {
      background-color: var(--highlight-sentence);
    }
    .sentence-wrap.learned:hover {
      background-color: #bbf7d0; /* Darker green on hover */
    }

    .word-span {
      padding: 2px 1px;
      border-radius: 4px;
      transition: background 0.1s;
      position: relative;
    }

    .sentence-wrap:hover .word-span:hover {
      background-color: var(--highlight-word);
      color: #000;
    }
    
    /* Input Section */
    .input-section {
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1.5rem;
    }
    
    .input-section h3 { margin-top: 0; font-size: 1rem; margin-bottom: 0.5rem; }
    
    textarea {
      width: 100%;
      min-height: 100px;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      font-family: inherit;
      resize: vertical;
      margin-bottom: 1rem;
      background: #f9f9f9;
    }
    
    textarea:focus { outline: 2px solid var(--accent); background: #fff; }

    button.primary-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.95rem;
    }
    button.primary-btn:hover { opacity: 0.9; }

    /* OVERLAYS & MODALS */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      backdrop-filter: blur(2px);
    }
    .overlay.active { display: flex; }

    .modal {
      background: var(--paper);
      border-radius: var(--radius);
      padding: 2rem;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2);
      position: relative;
      animation: slideUp 0.2s ease-out;
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .modal h2 { margin-top: 0; }
    
    /* Selection Modal Specifics */
    .selection-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    
    .option-card {
      border: 2px solid var(--border);
      border-radius: 10px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .option-card:hover {
      border-color: var(--accent);
      background: #f8fafc;
      transform: translateY(-2px);
    }
    
    .option-card strong { display: block; font-size: 1.1rem; margin-bottom: 0.5rem; }
    .option-card span { font-size: 0.85rem; color: var(--muted); }

    .close-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--muted);
    }

    /* Flashcard UI (Reused/Adapted) */
    .flashcard-container {
      max-width: 650px; /* Wider for flashcards */
    }
    
    .flashcard-term { font-size: 2rem; font-weight: 700; text-align: center; margin-bottom: 0.5rem; }
    .flashcard-meta { text-align: center; color: var(--muted); font-size: 0.9rem; margin-bottom: 1.5rem; }
    
    .flashcard-details {
      background: #f8fafc;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      max-height: 40vh;
      overflow-y: auto;
    }

    .grade-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      margin-top: 1.5rem;
    }
    
    .grade-buttons button {
      padding: 0.8rem;
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }

    /* Mini Card Grid (from original) */
    .mini-card-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.5rem; }
    .mini-card { background: white; border: 1px solid var(--border); border-radius: 8px; padding: 0.75rem; font-size: 0.9rem; }
    .mini-card strong { display: block; margin-bottom: 0.25rem; color: var(--muted); font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.5px; }

  </style>
</head>
<body>

  <header>
    <h1>French Reader</h1>
    <div class="stats" id="headerStats">0 Sentences Loaded</div>
  </header>

  <main>
    <!-- 1. The Reader Area -->
    <div class="reader-container" id="readerView">
      <div class="empty-state">
        Paste text below and click "Add to Reader" to get started.
      </div>
    </div>

    <!-- 2. The Input Area (Bottom) -->
    <div class="input-section">
      <h3>Add Text</h3>
      <textarea id="textInput" placeholder="Paste French text here..."></textarea>
      <button class="primary-btn" id="addToReaderBtn">Add to Reader</button>
    </div>
  </main>

  <!-- OVERLAY 1: Selection Mode (Word vs Sentence) -->
  <div class="overlay" id="selectionModal">
    <div class="modal">
      <button class="close-btn" id="closeSelection">×</button>
      <h2>How would you like to be tested?</h2>
      <p>Selected word: <strong id="selectedWordDisplay">...</strong></p>
      
      <div class="selection-options">
        <div class="option-card" id="btnStudyWord">
          <strong>Word</strong>
          <span>Create a 1-card deck for this word only.</span>
        </div>
        <div class="option-card" id="btnStudySentence">
          <strong>Sentence</strong>
          <span>Study all words in this sentence. (Mark green when done)</span>
        </div>
      </div>
    </div>
  </div>

  <!-- OVERLAY 2: Flashcard / Testing -->
  <div class="overlay" id="flashcardModal">
    <div class="modal flashcard-container">
      <button class="close-btn" id="closeFlashcard">×</button>
      
      <div style="display:flex; justify-content:space-between; margin-bottom:1rem;">
        <span class="pill" id="deckLabel">Deck</span>
        <span class="pill" id="deckProgress">0 / 0</span>
      </div>

      <div id="flashcardContent">
        <div class="flashcard-term" id="cardTerm">Bonjour</div>
        <div class="flashcard-meta" id="cardSubtitle">...</div>
        <div class="flashcard-details" id="cardMeanings">
          <!-- Content injected via JS -->
        </div>
      </div>

      <div class="grade-buttons">
        <button style="background:#e74c3c" data-grade="again">Again</button>
        <button style="background:#e67e22" data-grade="hard">Hard</button>
        <button style="background:#27ae60" data-grade="good">Good</button>
        <button style="background:#16a085" data-grade="easy">Easy</button>
      </div>
    </div>
  </div>

  <script src="../dir/frenchwordsApi.js"></script>
  <script>
    // --- State Management ---
    const STORAGE_KEYS = {
      textData: 'reader-sentences-v2', // Stores array of sentence strings
      progress: 'reader-progress-v2',  // Stores learned status
      srs: 'reader-srs'
    };

    const dom = {
      readerView: document.getElementById('readerView'),
      textInput: document.getElementById('textInput'),
      addBtn: document.getElementById('addToReaderBtn'),
      headerStats: document.getElementById('headerStats'),
      
      // Selection Modal
      selectionModal: document.getElementById('selectionModal'),
      selectedWordDisplay: document.getElementById('selectedWordDisplay'),
      btnStudyWord: document.getElementById('btnStudyWord'),
      btnStudySentence: document.getElementById('btnStudySentence'),
      closeSelection: document.getElementById('closeSelection'),

      // Flashcard Modal
      flashcardModal: document.getElementById('flashcardModal'),
      closeFlashcard: document.getElementById('closeFlashcard'),
      cardTerm: document.getElementById('cardTerm'),
      cardSubtitle: document.getElementById('cardSubtitle'),
      cardMeanings: document.getElementById('cardMeanings'),
      deckLabel: document.getElementById('deckLabel'),
      deckProgress: document.getElementById('deckProgress'),
      gradeButtons: document.querySelectorAll('.grade-buttons button')
    };

    let sentenceData = loadJson(STORAGE_KEYS.textData, []); 
    let progress = loadJson(STORAGE_KEYS.progress, {}); // Map: sentenceText -> { status: 'complete', cards: {} }
    let srsState = loadJson(STORAGE_KEYS.srs, {});
    
    // Temp State for interactions
    let currentSelection = { word: '', sentenceIndex: null, sentenceText: '' };
    let activeDeck = { queue: [], pointer: 0, mode: 'word' }; // mode: 'word' | 'sentence'

    function loadJson(key, fallback) {
      try { const r = localStorage.getItem(key); return r ? JSON.parse(r) : fallback; }
      catch { return fallback; }
    }
    
    function saveState() {
      localStorage.setItem(STORAGE_KEYS.textData, JSON.stringify(sentenceData));
      localStorage.setItem(STORAGE_KEYS.progress, JSON.stringify(progress));
      localStorage.setItem(STORAGE_KEYS.srs, JSON.stringify(srsState));
    }

    // --- Parsing & Rendering ---

    function parseText(rawText) {
      // Simple parse: split by common sentence delimiters, keep delimiter
      // Clean newlines
      const clean = rawText.replace(/\n+/g, ' ');
      // Split looking behind for . ! ?
      const rawSentences = clean.split(/(?<=[.!?…])\s+/);
      return rawSentences.map(s => s.trim()).filter(Boolean);
    }

    function renderReader() {
      if (sentenceData.length === 0) {
        dom.readerView.innerHTML = `<div class="empty-state">Paste text below and click "Add to Reader" to get started.</div>`;
        dom.headerStats.textContent = "0 Sentences";
        return;
      }

      dom.readerView.innerHTML = '';
      const fragment = document.createDocumentFragment();

      sentenceData.forEach((text, index) => {
        const wrap = document.createElement('span');
        wrap.className = 'sentence-wrap';
        wrap.dataset.index = index;
        
        // Check if learned
        const key = text.trim().toLowerCase();
        if (progress[key]?.status === 'complete') {
          wrap.classList.add('learned');
        }

        // Tokenize words
        const tokens = text.split(/(\s+|[.,!?;:()"]+)/); // Split keeping separators
        
        tokens.forEach(token => {
          if (token.trim().length === 0 || /^[.,!?;:()"]+$/.test(token)) {
            // Punctuation or space: just append
            wrap.appendChild(document.createTextNode(token));
          } else {
            // Interactive word
            const wordSpan = document.createElement('span');
            wordSpan.className = 'word-span';
            wordSpan.textContent = token;
            // Interaction Event
            wordSpan.onclick = (e) => {
              e.stopPropagation(); // Prevent sentence click if we had one
              openSelectionModal(token, index, text);
            };
            wrap.appendChild(wordSpan);
          }
        });

        // Optional: Wrap sentences in paragraphs visually if needed, 
        // but for now strictly inline-block flow usually works best for "blog" feel
        fragment.appendChild(wrap);
      });

      dom.readerView.appendChild(fragment);
      dom.headerStats.textContent = `${sentenceData.length} Sentences`;
    }

    // --- Interaction Logic ---

    dom.addBtn.addEventListener('click', () => {
      const text = dom.textInput.value;
      if (!text.trim()) return;
      
      const newSentences = parseText(text);
      sentenceData = [...newSentences, ...sentenceData]; // Add new text to TOP
      
      dom.textInput.value = '';
      saveState();
      renderReader();
    });

    function openSelectionModal(word, sIndex, sText) {
      // Clean word (remove punctuation if any stuck)
      const cleanWord = word.replace(/[^\p{L}'’-]/gu, '');
      currentSelection = { word: cleanWord, sentenceIndex: sIndex, sentenceText: sText };
      
      dom.selectedWordDisplay.textContent = cleanWord;
      dom.selectionModal.classList.add('active');
    }

    // Modal Buttons
    dom.btnStudyWord.addEventListener('click', async () => {
      dom.selectionModal.classList.remove('active');
      await startDeck('word');
    });

    dom.btnStudySentence.addEventListener('click', async () => {
      dom.selectionModal.classList.remove('active');
      await startDeck('sentence');
    });

    dom.closeSelection.addEventListener('click', () => dom.selectionModal.classList.remove('active'));
    dom.closeFlashcard.addEventListener('click', () => dom.flashcardModal.classList.remove('active'));

    // --- Flashcard / Deck Logic ---

    async function startDeck(mode) {
      dom.flashcardModal.classList.add('active');
      dom.cardMeanings.innerHTML = '<div style="padding:2rem; text-align:center;">Loading cards...</div>';
      
      activeDeck.mode = mode;
      activeDeck.pointer = 0;
      activeDeck.queue = [];

      await window.frenchWordsApi.preloadFrenchWordData();

      if (mode === 'word') {
        // Just look up the specific word
        const cards = await generateCardsFromText(currentSelection.word);
        // Filter to ensure we only get the word we clicked roughly
        activeDeck.queue = cards.filter(c => 
          c.display.toLowerCase().includes(currentSelection.word.toLowerCase()) || 
          currentSelection.word.toLowerCase().includes(c.display.toLowerCase())
        );
        if (activeDeck.queue.length === 0 && cards.length > 0) activeDeck.queue = cards; // Fallback
        dom.deckLabel.textContent = "Word Study";
      } else {
        // Sentence mode
        const cards = await generateCardsFromText(currentSelection.sentenceText);
        activeDeck.queue = cards;
        dom.deckLabel.textContent = "Sentence Study";
      }

      if (activeDeck.queue.length === 0) {
        dom.cardMeanings.innerHTML = '<div style="padding:1rem; text-align:center; color:red">No definitions found for this input.</div>';
        return;
      }

      showCard(0);
    }

    async function generateCardsFromText(textStr) {
      // Use existing API logic
      const lookup = await window.frenchWordsApi.lookupFrenchWords(textStr);
      const cards = [];
      
      // Convert API lookup format to Flashcard format
      lookup.forEach((entry, idx) => {
        const card = {
          id: entry.word + '-' + idx, // Simple ID
          display: entry.word || entry.originalText,
          original: entry.originalText,
          meanings: entry.meanings,
          category: entry.category,
          gender: entry.gender,
          found: entry.found,
          wiktionaryLookupWord: entry.word || entry.originalText,
          // Context
          sentence: currentSelection.sentenceText
        };
        cards.push(card);
      });
      return cards;
    }

    async function showCard(index) {
      if (index >= activeDeck.queue.length) {
        // Deck Complete
        finishDeck();
        return;
      }

      const card = activeDeck.queue[index];
      dom.deckProgress.textContent = `${index + 1} / ${activeDeck.queue.length}`;
      
      // Render Card Front
      dom.cardTerm.textContent = card.display;
      dom.cardSubtitle.textContent = (card.category || '') + (card.gender ? ` • ${card.gender}` : '');
      
      // Wiktionary fallback logic (copied from your snippet idea)
      if (!card.found && !card.meanings) {
         dom.cardMeanings.innerHTML = 'Looking up...';
         const defs = await window.frenchWordsApi.fetchWiktionaryMeaning(card.wiktionaryLookupWord);
         card.meanings = defs || ['No definition found'];
         card.found = true;
      }

      // Render Body
      let html = `<div class="mini-card-grid">`;
      
      const addToGrid = (label, val) => {
         if(!val) return;
         if(Array.isArray(val) && val.length === 0) return;
         html += `
          <div class="mini-card">
            <strong>${label}</strong>
            <div>${Array.isArray(val) ? `<ul>${val.map(v=>`<li>${v}</li>`).join('')}</ul>` : val}</div>
          </div>`;
      };

      addToGrid('Meanings', card.meanings);
      addToGrid('Context', card.sentence);
      
      html += `</div>`;
      dom.cardMeanings.innerHTML = html;
    }

    function finishDeck() {
      dom.flashcardModal.classList.remove('active');
      
      if (activeDeck.mode === 'sentence') {
        // Mark sentence as Green
        const key = currentSelection.sentenceText.trim().toLowerCase();
        if (!progress[key]) progress[key] = { cards: {} };
        progress[key].status = 'complete';
        saveState();
        renderReader(); // Re-render to show green
      }
      
      // Word mode does nothing on completion per request
    }

    // --- Grading Logic ---
    dom.gradeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const grade = btn.dataset.grade; // again, hard, good, easy
        
        // In this specific simplified logic:
        // If "Again", we re-queue the card at the end? 
        // Or simply proceed. The request says "If I complete the sentence deck show it as green."
        // implying getting to the end is enough, or getting them right. 
        // Let's implement simple queueing: if grade is 'again', push to end of queue.
        
        const currentCard = activeDeck.queue[activeDeck.pointer];
        
        // Save SRS Data (Optional for persistence, though prompt focused on UI flow)
        // scheduleCard(currentCard.id, grade); // Call SRS logic if you want persistent intervals
        
        if (grade === 'again') {
          activeDeck.queue.push(currentCard); // Add to back
        }

        activeDeck.pointer++;
        showCard(activeDeck.pointer);
      });
    });

    // Initial Load
    renderReader();

  </script>
</body>
</html>
