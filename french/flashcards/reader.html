<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>French Reader</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f7f6f3;
      --paper: #ffffff;
      --text: #2c3e50;
      --muted: #7f8c8d;
      --border: #e0ded8;
      --highlight-sentence: #e3e8ef;
      --highlight-word: #cbd5e1;
      --success-bg: #dcfce7;
      --success-border: #86efac;
      --accent: #2c3e50;
      --radius: 12px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
      --font-read: 'Inter', sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--font-read);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      background: var(--paper);
      border-bottom: 1px solid var(--border);
      padding: 1rem 1.5rem;
      position: sticky;
      top: 0;
      z-index: 50;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.03);
    }
    header h1 { margin: 0; font-size: 1.1rem; font-weight: 700; color: var(--accent); }
    header .stats { font-size: 0.85rem; color: var(--muted); }

    /* Main Container */
    main {
      flex: 1;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    /* Reader View */
    .reader-container {
      background: var(--paper);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 4rem 3rem;
      min-height: 200px;
      line-height: 1.8;
      font-size: 1.125rem;
    }

    .blog-title {
      font-size: 2.5rem;
      font-weight: 800;
      margin-top: 0;
      margin-bottom: 2rem;
      line-height: 1.2;
      color: var(--text);
      display: none;
    }
    .blog-title.visible { display: block; }

    @media (max-width: 600px) {
      .reader-container { padding: 1.5rem; font-size: 1rem; }
      .blog-title { font-size: 1.8rem; }
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      padding: 2rem;
      font-style: italic;
    }

    /* Text Interaction Styles */
    .sentence-wrap {
      padding: 0.15rem 0.2rem;
      border-radius: 6px;
      transition: background 0.1s ease;
      cursor: pointer;
      margin-right: 4px;
    }

    .sentence-wrap.learned {
      background-color: var(--success-bg);
      box-shadow: 0 0 0 1px var(--success-border);
    }

    .sentence-wrap:hover { background-color: var(--highlight-sentence); }
    .sentence-wrap.learned:hover { background-color: #bbf7d0; }

    .word-span {
      padding: 2px 1px;
      border-radius: 4px;
      transition: background 0.1s;
      position: relative;
    }

    .sentence-wrap:hover .word-span:hover {
      background-color: var(--highlight-word);
      color: #000;
    }
    
    /* Input Section */
    .input-section {
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1.5rem;
    }
    
    .input-section h3 { margin-top: 0; font-size: 1rem; margin-bottom: 1rem; }
    .input-group { display: flex; flex-direction: column; gap: 0.8rem; }

    input[type="text"], textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.8rem 1rem;
      font-family: inherit;
      background: #f9f9f9;
      font-size: 1rem;
    }
    
    textarea { min-height: 120px; resize: vertical; }
    input[type="text"], textarea:focus { outline: 2px solid var(--accent); background: #fff; }

    button.primary-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.85rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
      align-self: flex-start;
    }
    button.primary-btn:hover { opacity: 0.9; }

    /* OVERLAYS & MODALS */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      backdrop-filter: blur(2px);
    }
    .overlay.active { display: flex; }

    .modal {
      background: var(--paper);
      border-radius: var(--radius);
      padding: 2rem;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2);
      position: relative;
      animation: slideUp 0.2s ease-out;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .modal h2 { margin-top: 0; }
    
    .selection-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 1.5rem;
    }
    
    .option-card {
      border: 2px solid var(--border);
      border-radius: 10px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .option-card:hover {
      border-color: var(--accent);
      background: #f8fafc;
      transform: translateY(-2px);
    }
    
    .option-card strong { display: block; font-size: 1.1rem; margin-bottom: 0.5rem; }
    .option-card span { font-size: 0.85rem; color: var(--muted); }

    .close-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--muted);
      z-index: 10;
    }

    /* --- FLASHCARD UI --- */
    .flashcard-container { max-width: 700px; height: 85vh; }
    
    .flashcard-term { font-size: 2.2rem; font-weight: 700; text-align: center; margin-bottom: 0.2rem; color: var(--accent); }
    .flashcard-meta { text-align: center; color: var(--muted); font-size: 0.9rem; margin-bottom: 1.2rem; min-height: 1.2rem; }
    
    .flashcard-details {
      flex: 1;
      overflow-y: auto;
      margin-bottom: 1rem;
      padding: 4px; /* Space for shadow */
    }

    .grade-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.5rem;
      margin-top: auto;
      flex-shrink: 0;
    }
    
    .grade-buttons button {
      padding: 0.9rem;
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
    }

    /* --- FLIPPABLE MINI CARDS --- */
    .mini-card-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); 
      gap: 0.75rem; 
      width: 100%;
    }

    /* Special Class for when there is only 1 item */
    .mini-card-grid.single-mode {
      grid-template-columns: 1fr;
      height: 100%;
    }

    .mini-card { 
      background: transparent;
      perspective: 1000px; /* Enable 3D effect */
      cursor: pointer;
      min-height: 140px;
    }

    /* Make the single card bigger */
    .mini-card-grid.single-mode .mini-card {
      min-height: 100%; /* Fill the container */
    }

    .mini-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      text-align: center;
      transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      transform-style: preserve-3d;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    }

    .mini-card.flipped .mini-card-inner {
      transform: rotateY(180deg);
    }

    .mini-card-face {
      position: absolute;
      inset: 0; /* fill parent */
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
    }

    /* Front Face Styles */
    .mini-card-front {
      background: #f8fafc;
      color: var(--accent);
    }
    .mini-card-front strong {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--muted);
    }

    /* Back Face Styles */
    .mini-card-back {
      transform: rotateY(180deg);
      background: #fff;
      overflow-y: auto; /* Allow scrolling if content is long */
      align-items: flex-start; /* Align text top-left usually better for content */
      text-align: left;
    }
    
    /* Adjust text alignment for back card based on content type */
    .mini-card-back-content {
      width: 100%;
    }

    .mini-card ul { margin: 0; padding-left: 1.2rem; }
    .mini-card li { margin-bottom: 0.2rem; }
    
    /* Example sentences styling */
    .example-line { margin-bottom: 0.75rem; border-bottom: 1px dashed #eee; padding-bottom: 0.5rem; }
    .example-line:last-child { border-bottom: none; }
    .example-fr { font-weight: 600; color: var(--accent); margin-bottom: 0.1rem; }
    .example-en { font-style: italic; color: var(--muted); font-size: 0.9rem; }

    /* Single Card Mode Typography Boost */
    .mini-card-grid.single-mode .mini-card-front strong { font-size: 1.2rem; }
    .mini-card-grid.single-mode .mini-card-back { font-size: 1.1rem; padding: 2rem; justify-content: start; }

  </style>
</head>
<body>

  <header>
    <h1>French Reader</h1>
    <div class="stats" id="headerStats">0 Sentences Loaded</div>
  </header>

  <main>
    <!-- 1. The Reader Area -->
    <div class="reader-container" id="readerView">
      <h1 class="blog-title" id="blogTitleDisplay"></h1>
      <div id="readerContent">
        <div class="empty-state">
          Paste text below and click "Add to Reader" to get started.
        </div>
      </div>
    </div>

    <!-- 2. The Input Area (Bottom) -->
    <div class="input-section">
      <h3>Add Text</h3>
      <div class="input-group">
        <input type="text" id="titleInput" placeholder="Title (e.g., Chapter 1, Daily News)" />
        <textarea id="textInput" placeholder="Paste French text here..."></textarea>
        <button class="primary-btn" id="addToReaderBtn">Add to Reader</button>
      </div>
    </div>
  </main>

  <!-- OVERLAY 1: Selection Mode (Word vs Sentence) -->
  <div class="overlay" id="selectionModal">
    <div class="modal">
      <button class="close-btn" id="closeSelection">×</button>
      <h2>How would you like to be tested?</h2>
      <p>Selected word: <strong id="selectedWordDisplay">...</strong></p>
      
      <div class="selection-options">
        <div class="option-card" id="btnStudyWord">
          <strong>Word</strong>
          <span>Create a 1-card deck for this word only.</span>
        </div>
        <div class="option-card" id="btnStudySentence">
          <strong>Sentence</strong>
          <span>Study all words in this sentence. (Mark green when done)</span>
        </div>
      </div>
    </div>
  </div>

  <!-- OVERLAY 2: Flashcard / Testing -->
  <div class="overlay" id="flashcardModal">
    <div class="modal flashcard-container">
      <button class="close-btn" id="closeFlashcard">×</button>
      
      <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem; flex-shrink:0;">
        <span class="pill" id="deckLabel">Deck</span>
        <span class="pill" id="deckProgress">0 / 0</span>
      </div>

      <div class="flashcard-term" id="cardTerm">Bonjour</div>
      <div class="flashcard-meta" id="cardSubtitle">...</div>
      
      <div class="flashcard-details" id="cardMeanings">
        <!-- Grid of flippable cards goes here -->
      </div>

      <div class="grade-buttons">
        <button style="background:#e74c3c" data-grade="again">Again</button>
        <button style="background:#e67e22" data-grade="hard">Hard</button>
        <button style="background:#27ae60" data-grade="good">Good</button>
        <button style="background:#16a085" data-grade="easy">Easy</button>
      </div>
    </div>
  </div>

  <script src="../dir/frenchwordsApi.js"></script>
  <script>
    // --- State Management ---
    const STORAGE_KEYS = {
      title: 'reader-title-v2',
      textData: 'reader-sentences-v2', 
      progress: 'reader-progress-v2',  
      srs: 'reader-srs'
    };

    const dom = {
      readerContent: document.getElementById('readerContent'),
      blogTitleDisplay: document.getElementById('blogTitleDisplay'),
      titleInput: document.getElementById('titleInput'),
      textInput: document.getElementById('textInput'),
      addBtn: document.getElementById('addToReaderBtn'),
      headerStats: document.getElementById('headerStats'),
      
      // Selection Modal
      selectionModal: document.getElementById('selectionModal'),
      selectedWordDisplay: document.getElementById('selectedWordDisplay'),
      btnStudyWord: document.getElementById('btnStudyWord'),
      btnStudySentence: document.getElementById('btnStudySentence'),
      closeSelection: document.getElementById('closeSelection'),

      // Flashcard Modal
      flashcardModal: document.getElementById('flashcardModal'),
      closeFlashcard: document.getElementById('closeFlashcard'),
      cardTerm: document.getElementById('cardTerm'),
      cardSubtitle: document.getElementById('cardSubtitle'),
      cardMeanings: document.getElementById('cardMeanings'),
      deckLabel: document.getElementById('deckLabel'),
      deckProgress: document.getElementById('deckProgress'),
      gradeButtons: document.querySelectorAll('.grade-buttons button')
    };

    let sentenceData = loadJson(STORAGE_KEYS.textData, []); 
    let currentTitle = localStorage.getItem(STORAGE_KEYS.title) || '';
    let progress = loadJson(STORAGE_KEYS.progress, {}); 
    let srsState = loadJson(STORAGE_KEYS.srs, {});
    
    // Temp State for interactions
    let currentSelection = { word: '', sentenceIndex: null, sentenceText: '' };
    let activeDeck = { queue: [], pointer: 0, mode: 'word' }; 

    function loadJson(key, fallback) {
      try { const r = localStorage.getItem(key); return r ? JSON.parse(r) : fallback; }
      catch { return fallback; }
    }
    
    function saveState() {
      localStorage.setItem(STORAGE_KEYS.textData, JSON.stringify(sentenceData));
      localStorage.setItem(STORAGE_KEYS.title, currentTitle);
      localStorage.setItem(STORAGE_KEYS.progress, JSON.stringify(progress));
      localStorage.setItem(STORAGE_KEYS.srs, JSON.stringify(srsState));
    }

    // --- Parsing & Rendering ---

    function parseText(rawText) {
      const clean = rawText.replace(/\n+/g, ' ');
      const rawSentences = clean.split(/(?<=[.!?…])\s+/);
      return rawSentences.map(s => s.trim()).filter(Boolean);
    }

    function renderReader() {
      if (currentTitle) {
        dom.blogTitleDisplay.textContent = currentTitle;
        dom.blogTitleDisplay.classList.add('visible');
      } else {
        dom.blogTitleDisplay.classList.remove('visible');
      }

      if (sentenceData.length === 0) {
        dom.readerContent.innerHTML = `<div class="empty-state">Paste text below and click "Add to Reader" to get started.</div>`;
        dom.headerStats.textContent = "0 Sentences";
        return;
      }

      dom.readerContent.innerHTML = '';
      const fragment = document.createDocumentFragment();

      sentenceData.forEach((text, index) => {
        const wrap = document.createElement('span');
        wrap.className = 'sentence-wrap';
        wrap.dataset.index = index;
        
        const key = text.trim().toLowerCase();
        if (progress[key]?.status === 'complete') {
          wrap.classList.add('learned');
        }

        const tokens = text.split(/(\s+|[.,!?;:()"]+)/);
        
        tokens.forEach(token => {
          if (token.trim().length === 0 || /^[.,!?;:()"]+$/.test(token)) {
            wrap.appendChild(document.createTextNode(token));
          } else {
            const wordSpan = document.createElement('span');
            wordSpan.className = 'word-span';
            wordSpan.textContent = token;
            wordSpan.onclick = (e) => {
              e.stopPropagation(); 
              openSelectionModal(token, index, text);
            };
            wrap.appendChild(wordSpan);
          }
        });

        fragment.appendChild(wrap);
      });

      dom.readerContent.appendChild(fragment);
      dom.headerStats.textContent = `${sentenceData.length} Sentences`;
    }

    // --- Interaction Logic ---

    dom.addBtn.addEventListener('click', () => {
      const text = dom.textInput.value;
      const title = dom.titleInput.value;

      if (!text.trim() && !title.trim()) return;
      if (title.trim()) currentTitle = title.trim();
      if (text.trim()) {
        const newSentences = parseText(text);
        sentenceData = [...sentenceData, ...newSentences]; 
      }
      dom.textInput.value = '';
      dom.titleInput.value = '';
      saveState();
      renderReader();
    });

    function openSelectionModal(word, sIndex, sText) {
      const cleanWord = word.replace(/[^\p{L}'’-]/gu, '');
      currentSelection = { word: cleanWord, sentenceIndex: sIndex, sentenceText: sText };
      
      dom.selectedWordDisplay.textContent = cleanWord;
      dom.selectionModal.classList.add('active');
    }

    dom.btnStudyWord.addEventListener('click', async () => {
      dom.selectionModal.classList.remove('active');
      await startDeck('word');
    });

    dom.btnStudySentence.addEventListener('click', async () => {
      dom.selectionModal.classList.remove('active');
      await startDeck('sentence');
    });

    dom.closeSelection.addEventListener('click', () => dom.selectionModal.classList.remove('active'));
    dom.closeFlashcard.addEventListener('click', () => dom.flashcardModal.classList.remove('active'));

    // --- Flashcard / Deck Logic ---

    async function startDeck(mode) {
      dom.flashcardModal.classList.add('active');
      dom.cardMeanings.innerHTML = '<div style="padding:2rem; text-align:center;">Loading cards...</div>';
      
      activeDeck.mode = mode;
      activeDeck.pointer = 0;
      activeDeck.queue = [];

      await window.frenchWordsApi.preloadFrenchWordData();

      if (mode === 'word') {
        const cards = await generateCardsFromText(currentSelection.word);
        activeDeck.queue = cards.filter(c => 
          c.display.toLowerCase().includes(currentSelection.word.toLowerCase()) || 
          currentSelection.word.toLowerCase().includes(c.display.toLowerCase())
        );
        if (activeDeck.queue.length === 0 && cards.length > 0) activeDeck.queue = cards;
        dom.deckLabel.textContent = "Word Study";
      } else {
        const cards = await generateCardsFromText(currentSelection.sentenceText);
        activeDeck.queue = cards;
        dom.deckLabel.textContent = "Sentence Study";
      }

      if (activeDeck.queue.length === 0) {
        dom.cardMeanings.innerHTML = '<div style="padding:1rem; text-align:center; color:red">No definitions found for this input.</div>';
        return;
      }

      showCard(0);
    }

    async function generateCardsFromText(textStr) {
      const lookup = await window.frenchWordsApi.lookupFrenchWords(textStr);
      const cards = [];
      lookup.forEach((entry, idx) => {
        const card = {
          id: entry.word + '-' + idx,
          display: entry.word || entry.originalText,
          meanings: entry.meanings,
          category: entry.category,
          gender: entry.gender,
          pronouns: entry.pronouns,
          tense: entry.tense,
          conjugatedFrom: entry.conjugatedFrom,
          conjugatedFromMeaning: entry.conjugatedFromMeaning,
          exampleSentences: entry.exampleSentences,
          notes: entry.notes,
          found: entry.found,
          wiktionaryLookupWord: entry.word || entry.originalText,
          sentence: currentSelection.sentenceText
        };
        cards.push(card);
      });
      return cards;
    }

    async function showCard(index) {
      if (index >= activeDeck.queue.length) {
        finishDeck();
        return;
      }

      const card = activeDeck.queue[index];
      dom.deckProgress.textContent = `${index + 1} / ${activeDeck.queue.length}`;
      dom.cardTerm.textContent = card.display;
      
      let sub = [];
      if(card.category) sub.push(card.category);
      if(card.gender) sub.push(card.gender);
      dom.cardSubtitle.textContent = sub.join(' • ');
      
      if (!card.found && !card.meanings) {
         dom.cardMeanings.innerHTML = 'Looking up...';
         const defs = await window.frenchWordsApi.fetchWiktionaryMeaning(card.wiktionaryLookupWord);
         card.meanings = defs || ['No definition found'];
         card.found = true;
      }

      // Prepare Items
      const items = [];
      
      // Helper to push items to array
      const pushItem = (label, val, type='text') => {
         if(!val) return;
         if(Array.isArray(val) && val.length === 0) return;
         items.push({ label, val, type });
      };

      // Exclude 'Original' and 'Word' as requested
      pushItem('Meanings', card.meanings, 'list');
      pushItem('Category', card.category);
      pushItem('Gender', card.gender);
      pushItem('Pronouns', card.pronouns, 'list');
      pushItem('Tense', card.tense, 'list');
      pushItem('Conjugated From', card.conjugatedFrom);
      pushItem('Base Meaning', card.conjugatedFromMeaning, 'list');
      pushItem('Examples', card.exampleSentences, 'examples');
      pushItem('Notes', card.notes);
      pushItem('Context', card.sentence);

      // Render Grid
      dom.cardMeanings.innerHTML = '';
      const grid = document.createElement('div');
      grid.className = 'mini-card-grid';
      
      // If only 1 item, switch to Single Mode (Big Card)
      if (items.length === 1) {
        grid.classList.add('single-mode');
      }

      items.forEach(item => {
         const cardEl = document.createElement('div');
         cardEl.className = 'mini-card';
         
         // Inner Flip Container
         const inner = document.createElement('div');
         inner.className = 'mini-card-inner';
         
         // Front Face
         const front = document.createElement('div');
         front.className = 'mini-card-face mini-card-front';
         front.innerHTML = `<strong>${item.label}</strong>`;
         
         // Back Face
         const back = document.createElement('div');
         back.className = 'mini-card-face mini-card-back';
         
         let contentHtml = '';
         if (item.type === 'list' && Array.isArray(item.val)) {
            contentHtml = `<ul>${item.val.map(v=>`<li>${v}</li>`).join('')}</ul>`;
         } else if (item.type === 'examples' && Array.isArray(item.val)) {
            contentHtml = item.val.map(ex => `
              <div class="example-line">
                <div class="example-fr">${ex.french}</div>
                ${ex.english ? `<div class="example-en">${ex.english}</div>` : ''}
              </div>
            `).join('');
         } else {
            contentHtml = item.val;
         }
         
         back.innerHTML = `<div class="mini-card-back-content">${contentHtml}</div>`;

         inner.appendChild(front);
         inner.appendChild(back);
         cardEl.appendChild(inner);

         // Flip Logic
         cardEl.addEventListener('click', () => cardEl.classList.toggle('flipped'));
         
         grid.appendChild(cardEl);
      });

      dom.cardMeanings.appendChild(grid);
    }

    function finishDeck() {
      dom.flashcardModal.classList.remove('active');
      if (activeDeck.mode === 'sentence') {
        const key = currentSelection.sentenceText.trim().toLowerCase();
        if (!progress[key]) progress[key] = { cards: {} };
        progress[key].status = 'complete';
        saveState();
        renderReader(); 
      }
    }

    dom.gradeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const grade = btn.dataset.grade;
        if (grade === 'again') {
          activeDeck.queue.push(activeDeck.queue[activeDeck.pointer]);
        }
        activeDeck.pointer++;
        showCard(activeDeck.pointer);
      });
    });

    renderReader();

  </script>
</body>
</html>
