<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>French Reader</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #f7f6f3;
      --paper: #ffffff;
      --text: #2c3e50;
      --muted: #64748b;
      --border: #e2e8f0;
      --highlight-sentence: #e3e8ef;
      --highlight-word: #cbd5e1;
      --success-bg: #dcfce7;
      --success-border: #86efac;
      --accent: #334155;
      --accent-blue: #2563eb;
      --radius: 12px;
      --shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
      --font-read: 'Inter', system-ui, -apple-system, sans-serif;
    }
    
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: var(--font-read);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* Header */
    header {
      background: var(--paper);
      border-bottom: 1px solid var(--border);
      padding: 1rem 1.5rem;
      position: sticky;
      top: 0;
      z-index: 50;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 10px rgba(0,0,0,0.03);
    }
    header h1 { margin: 0; font-size: 1.1rem; font-weight: 700; color: var(--accent); }
    header .stats { font-size: 0.85rem; color: var(--muted); }

    /* Main Container */
    main {
      flex: 1;
      width: 100%;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 2rem;
    }

    /* Reader View */
    .reader-container {
      background: var(--paper);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 4rem 3rem;
      min-height: 200px;
      line-height: 1.8;
      font-size: 1.125rem;
    }

    .blog-title {
      font-size: 2.5rem;
      font-weight: 800;
      margin-top: 0;
      margin-bottom: 2rem;
      line-height: 1.2;
      color: var(--text);
      display: none;
    }
    .blog-title.visible { display: block; }

    @media (max-width: 600px) {
      .reader-container { padding: 1.5rem; font-size: 1rem; }
      .blog-title { font-size: 1.8rem; }
    }

    .empty-state {
      text-align: center;
      color: var(--muted);
      padding: 2rem;
      font-style: italic;
    }

    /* Text Interaction Styles */
    .sentence-wrap {
      padding: 0.15rem 0.2rem;
      border-radius: 6px;
      transition: background 0.1s ease;
      cursor: pointer;
      margin-right: 4px;
    }

    .sentence-wrap.learned {
      background-color: var(--success-bg);
      box-shadow: 0 0 0 1px var(--success-border);
    }

    .sentence-wrap:hover { background-color: var(--highlight-sentence); }
    .sentence-wrap.learned:hover { background-color: #bbf7d0; }

    .word-span {
      padding: 2px 1px;
      border-radius: 4px;
      transition: background 0.1s;
      position: relative;
    }

    .sentence-wrap:hover .word-span:hover {
      background-color: var(--highlight-word);
      color: #000;
    }

    /* Input Section */
    .input-section {
      background: var(--paper);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 1.5rem;
    }

    .input-section h3 { margin-top: 0; font-size: 1rem; margin-bottom: 1rem; }
    .input-group { display: flex; flex-direction: column; gap: 0.8rem; }

    input[type="text"], textarea {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.8rem 1rem;
      font-family: inherit;
      background: #f8fafc;
      font-size: 1rem;
      transition: all 0.2s;
    }

    textarea { min-height: 120px; resize: vertical; }
    input[type="text"]:focus, textarea:focus { outline: 2px solid var(--accent); background: #fff; }

    button.primary-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.85rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
      align-self: flex-start;
      transition: opacity 0.2s;
    }
    button.primary-btn:hover { opacity: 0.9; }

    /* OVERLAYS & MODALS */
    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      backdrop-filter: blur(4px);
    }
    .overlay.active { display: flex; }

    .modal {
      background: var(--paper);
      border-radius: var(--radius);
      padding: 2rem;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2);
      position: relative;
      animation: slideUp 0.2s ease-out;
      max-height: 90vh; /* Keeps modal inside viewport */
      display: flex;
      flex-direction: column;
    }

    @keyframes slideUp {
      from { transform: translateY(20px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    .modal h2 { margin-top: 0; }

    .selection-options {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .option-card {
      border: 2px solid var(--border);
      border-radius: 10px;
      padding: 1.5rem;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      background: #fff;
    }

    .option-card:hover {
      border-color: var(--accent);
      background: #f8fafc;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
    }

    .option-card strong { display: block; font-size: 1.1rem; margin-bottom: 0.5rem; }
    .option-card span { font-size: 0.85rem; color: var(--muted); }

    .close-btn {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--muted);
      z-index: 10;
    }

    /* --- FLASHCARD UI --- */
    /* Fixed height container to allow internal scrolling */
    .flashcard-container { max-width: 700px; height: 90vh; padding: 0; overflow: hidden; }
    
    .flashcard-header {
      padding: 1.5rem 2rem 0.5rem 2rem;
      flex-shrink: 0;
      background: white;
      z-index: 2;
    }

    .flashcard-term { font-size: 2.2rem; font-weight: 700; text-align: center; margin-bottom: 0.2rem; color: var(--accent); }
    .flashcard-meta { text-align: center; color: var(--muted); font-size: 0.95rem; margin-bottom: 0.5rem; min-height: 1.2rem; font-weight: 500; }

    /* The Scrollable Area */
    .flashcard-scroll-area {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 2rem;
      scroll-behavior: smooth;
    }

    .grade-buttons {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 0.75rem;
      padding: 1rem 2rem 2rem 2rem;
      background: white;
      border-top: 1px solid var(--border);
      flex-shrink: 0;
    }

    .grade-buttons button {
      padding: 1rem;
      border: none;
      border-radius: 10px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      font-size: 1rem;
      transition: transform 0.1s, opacity 0.2s;
    }
    .grade-buttons button:active { transform: scale(0.98); }

    /* --- FLIPPABLE MINI CARDS --- */
    .mini-card-grid { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); 
      gap: 1rem; 
      width: 100%;
      margin-bottom: 1.5rem;
    }

    /* Single Item Mode */
    .mini-card-grid.single-mode {
      grid-template-columns: 1fr;
    }

    .mini-card { 
      background: transparent;
      perspective: 1000px;
      cursor: pointer;
      min-height: 200px; 
    }

    .mini-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      text-align: center;
      transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      transform-style: preserve-3d;
      border-radius: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.06);
    }

    .mini-card.flipped .mini-card-inner { transform: rotateY(180deg); }

    .mini-card-face {
      position: absolute;
      inset: 0;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      border: 1px solid var(--border);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      background: white;
    }

    /* Front Face */
    .mini-card-front {
      background: #f8fafc;
      color: var(--accent);
    }
    .mini-card-front strong {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--muted);
      font-weight: 700;
    }

    /* Back Face - Centered but Scrollable */
    .mini-card-back {
      transform: rotateY(180deg);
      background: #fff;
      display: flex;
      flex-direction: column;
      /* 
        We use flex-direction column.
        We do NOT use justify-content: center here because that causes the top cut-off bug.
        Instead we handle centering inside the child wrapper.
      */
      padding: 0;
    }

    .mini-card-back-content {
      /* Fallback for simple text cards */
      width: 100%;
      font-size: 1rem;
      color: var(--text);
      line-height: 1.5;
      text-align: center;
      padding: 1.5rem;
      margin: auto 0; /* Centers vertically */
    }

    /* --- PAGINATION STYLES --- */
    .pagination-wrapper {
      display: flex;
      flex-direction: column;
      height: 100%;
      width: 100%;
      padding: 1rem 1.5rem;
      overflow: hidden; /* Contains the scrollable area */
    }
    
    .pagination-content {
      /* 
         This is the magic fix:
         1. overflow-y: auto -> allows scrolling if text is huge.
         2. margin: auto 0 -> Pushes it to the middle if small, but starts at top if big.
      */
      flex: 1;
      overflow-y: auto; 
      display: flex;
      flex-direction: column;
      margin: 0; /* Reset */
    }

    .pagination-content-inner {
        margin: auto 0; /* Centers the text block vertically */
        width: 100%;
        text-align: center; /* Center alignment requested */
        font-size: 1.1rem;
        line-height: 1.6;
    }

    /* Ensure list items inside the content look nice */
    .pagination-content-inner p { margin-top: 0; }
    .pagination-content-inner ul, .pagination-content-inner ol { 
        text-align: left; /* Keep lists left-aligned for readability */
        padding-left: 1.5rem; 
        margin: 0.5rem auto;
        display: inline-block; /* Helps center the list block itself */
        width: 100%;
    }
    
    /* Formatting from API */
    .pagination-content-inner b, .pagination-content-inner strong { color: var(--accent); font-weight: 700; }
    .pagination-content-inner i, .pagination-content-inner em { color: var(--muted); font-style: italic; }
    .pagination-content-inner a { color: inherit; text-decoration: none; pointer-events: none; border-bottom: 1px dotted var(--muted); }
    .pagination-content-inner span { display: inline; } /* Ensure spans are shown */

    .pagination-controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 0.75rem;
      border-top: 1px solid #f1f5f9;
      margin-top: auto; /* Pushes to bottom */
      font-size: 0.85rem;
      color: var(--muted);
      width: 100%;
      flex-shrink: 0;
    }

    .pager-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 50%;
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--accent);
      transition: background 0.1s;
    }
    .pager-btn:hover { background: #f1f5f9; }
    .pager-btn:disabled { opacity: 0.3; cursor: default; }

    /* --- REVEAL / SPOILER CARDS --- */
    .special-cards {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      margin-top: 0.5rem;
      flex-shrink: 0;
    }

    .special-card {
      width: 100%;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: #f8fafc;
      overflow: hidden; 
      position: relative;
      box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    }

    .special-card-header {
      padding: 1rem 1.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #f1f5f9;
      cursor: pointer;
      user-select: none;
    }
    
    .special-card-header h4 {
      margin: 0;
      font-size: 0.9rem;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      color: var(--muted);
    }

    .reveal-overlay {
      position: absolute;
      inset: 0;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10;
      cursor: pointer;
      transition: opacity 0.3s;
    }
    
    .reveal-btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 99px;
      font-weight: 600;
      font-size: 0.9rem;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    .special-card-body {
      padding: 1rem 1.25rem;
      background: white;
      opacity: 0; 
      transition: opacity 0.3s;
    }

    .special-card.revealed .reveal-overlay { opacity: 0; pointer-events: none; }
    .special-card.revealed .special-card-body { opacity: 1; }

    .example-line { margin: 0 0 0.75rem 0; padding-bottom: 0.75rem; border-bottom: 1px solid #f1f5f9; }
    .example-line:last-child { border: none; margin-bottom: 0; padding-bottom: 0; }
    .example-fr { font-size: 1.05rem; font-weight: 500; color: var(--text); }
    .example-en { font-size: 0.9rem; color: var(--muted); font-style: italic; margin-top: 2px; }

    .pronunciation-row { display: flex; align-items: center; gap: 0.75rem; }
    .speak-btn {
      border: 1px solid var(--border);
      background: white;
      border-radius: 999px;
      padding: 0.45rem 0.8rem;
      cursor: pointer;
      font-size: 1rem;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }
    .speak-btn:hover { background: #eef2ff; }
    .pronunciation-text { font-weight: 600; color: var(--accent); }

  </style>
</head>
<body>
  <header>
    <h1>French Reader</h1>
    <div class="stats" id="headerStats">0 Sentences Loaded</div>
  </header>
  <main>
    <!-- 1. The Reader Area -->
    <div class="reader-container" id="readerView">
      <h1 class="blog-title" id="blogTitleDisplay"></h1>
      <div id="readerContent">
        <div class="empty-state">
          Paste text below and click "Add to Reader" to get started.
        </div>
      </div>
    </div>
    
    <!-- 2. The Input Area (Bottom) -->
    <div class="input-section">
      <h3>Add Text</h3>
      <div class="input-group">
        <input type="text" id="titleInput" placeholder="Title (e.g., Chapter 1, Daily News)" />
        <textarea id="textInput" placeholder="Paste French text here..."></textarea>
        <button class="primary-btn" id="addToReaderBtn">Add to Reader</button>
      </div>
    </div>
  </main>

  <div class="overlay" id="selectionModal">
    <div class="modal">
      <button class="close-btn" id="closeSelection">Ã—</button>
      <h2>How would you like to be tested?</h2>
      <p>Selected word: <strong id="selectedWordDisplay">...</strong></p>
      
      <div class="selection-options">
        <div class="option-card" id="btnStudyWord">
          <strong>Word</strong>
          <span>Create a 1-card deck for this word only.</span>
        </div>
        <div class="option-card" id="btnStudySentence">
          <strong>Sentence</strong>
          <span>Study all words in this sentence.</span>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="flashcardModal">
    <div class="modal flashcard-container">
      
      <div class="flashcard-header">
        <button class="close-btn" id="closeFlashcard" style="position:static; float:right; margin-top:-0.5rem;">Ã—</button>
        <div style="display:flex; justify-content:space-between; margin-bottom:0.5rem;">
          <span class="pill" id="deckLabel">Deck</span>
          <span class="pill" id="deckProgress">0 / 0</span>
        </div>
        <div class="flashcard-term" id="cardTerm">Bonjour</div>
        <div class="flashcard-meta" id="cardSubtitle">...</div>
      </div>

      <div class="flashcard-scroll-area">
        <div id="cardMeanings"></div>

        <div class="special-cards">
          <div class="special-card" id="examplesCard">
            <div class="reveal-overlay" onclick="toggleReveal(this)">
              <button class="reveal-btn">Tap to Reveal Examples</button>
            </div>
            <div class="special-card-header">
              <h4>Example Sentences</h4>
            </div>
            <div class="special-card-body" id="examplesContent"></div>
          </div>

          <div class="special-card" id="pronunciationCard">
             <div class="reveal-overlay" onclick="toggleReveal(this)">
              <button class="reveal-btn">Tap to Reveal Pronunciation</button>
            </div>
            <div class="special-card-header">
              <h4>Pronunciation</h4>
            </div>
            <div class="special-card-body">
              <div class="pronunciation-row">
                <button class="speak-btn" id="speakButton" type="button">ðŸ”Š <span>Play</span></button>
                <div class="pronunciation-text" id="pronunciationText"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="grade-buttons">
        <button style="background:#ef4444; border-color:#ef4444" data-grade="again">Again</button>
        <button style="background:#f97316; border-color:#f97316" data-grade="hard">Hard</button>
        <button style="background:#22c55e; border-color:#22c55e" data-grade="good">Good</button>
        <button style="background:#14b8a6; border-color:#14b8a6" data-grade="easy">Easy</button>
      </div>
    </div>
  </div>

  <script src="../dir/frenchwordsApi.js"></script>
  <script>
    const STORAGE_KEYS = {
      title: 'reader-title-v2',
      textData: 'reader-sentences-v2', 
      progress: 'reader-progress-v2',  
      srs: 'reader-srs'
    };

    const dom = {
      readerContent: document.getElementById('readerContent'),
      blogTitleDisplay: document.getElementById('blogTitleDisplay'),
      titleInput: document.getElementById('titleInput'),
      textInput: document.getElementById('textInput'),
      addBtn: document.getElementById('addToReaderBtn'),
      headerStats: document.getElementById('headerStats'),
      
      selectionModal: document.getElementById('selectionModal'),
      selectedWordDisplay: document.getElementById('selectedWordDisplay'),
      btnStudyWord: document.getElementById('btnStudyWord'),
      btnStudySentence: document.getElementById('btnStudySentence'),
      closeSelection: document.getElementById('closeSelection'),

      flashcardModal: document.getElementById('flashcardModal'),
      closeFlashcard: document.getElementById('closeFlashcard'),
      cardTerm: document.getElementById('cardTerm'),
      cardSubtitle: document.getElementById('cardSubtitle'),
      cardMeanings: document.getElementById('cardMeanings'),
      deckLabel: document.getElementById('deckLabel'),
      deckProgress: document.getElementById('deckProgress'),
      gradeButtons: document.querySelectorAll('.grade-buttons button'),
      examplesContent: document.getElementById('examplesContent'),
      pronunciationText: document.getElementById('pronunciationText'),
      speakButton: document.getElementById('speakButton'),
      
      examplesCard: document.getElementById('examplesCard'),
      pronunciationCard: document.getElementById('pronunciationCard')
    };

    let sentenceData = loadJson(STORAGE_KEYS.textData, []); 
    let currentTitle = localStorage.getItem(STORAGE_KEYS.title) || '';
    let progress = loadJson(STORAGE_KEYS.progress, {}); 
    let srsState = loadJson(STORAGE_KEYS.srs, {});
    
    let currentSelection = { word: '', sentenceIndex: null, sentenceText: '' };
    let activeDeck = { queue: [], pointer: 0, mode: 'word' }; 

    function loadJson(key, fallback) {
      try { const r = localStorage.getItem(key); return r ? JSON.parse(r) : fallback; }
      catch { return fallback; }
    }
    
    function saveState() {
      localStorage.setItem(STORAGE_KEYS.textData, JSON.stringify(sentenceData));
      localStorage.setItem(STORAGE_KEYS.title, currentTitle);
      localStorage.setItem(STORAGE_KEYS.progress, JSON.stringify(progress));
      localStorage.setItem(STORAGE_KEYS.srs, JSON.stringify(srsState));
    }

    function parseText(rawText) {
      const clean = rawText.replace(/\n+/g, ' ');
      const rawSentences = clean.split(/(?<=[.!?â€¦])\s+/);
      return rawSentences.map(s => s.trim()).filter(Boolean);
    }

    function renderReader() {
      if (currentTitle) {
        dom.blogTitleDisplay.textContent = currentTitle;
        dom.blogTitleDisplay.classList.add('visible');
      } else {
        dom.blogTitleDisplay.classList.remove('visible');
      }

      if (sentenceData.length === 0) {
        dom.readerContent.innerHTML = `<div class="empty-state">Paste text below and click "Add to Reader" to get started.</div>`;
        dom.headerStats.textContent = "0 Sentences";
        return;
      }

      dom.readerContent.innerHTML = '';
      const fragment = document.createDocumentFragment();

      sentenceData.forEach((text, index) => {
        const wrap = document.createElement('span');
        wrap.className = 'sentence-wrap';
        wrap.dataset.index = index;
        
        const key = text.trim().toLowerCase();
        if (progress[key]?.status === 'complete') {
          wrap.classList.add('learned');
        }

        const tokens = text.split(/(\s+|[.,!?;:()"]+)/);
        tokens.forEach(token => {
          if (token.trim().length === 0 || /^[.,!?;:()"]+$/.test(token)) {
            wrap.appendChild(document.createTextNode(token));
          } else {
            const wordSpan = document.createElement('span');
            wordSpan.className = 'word-span';
            wordSpan.textContent = token;
            wordSpan.onclick = (e) => {
              e.stopPropagation(); 
              openSelectionModal(token, index, text);
            };
            wrap.appendChild(wordSpan);
          }
        });

        fragment.appendChild(wrap);
      });

      dom.readerContent.appendChild(fragment);
      dom.headerStats.textContent = `${sentenceData.length} Sentences`;
    }

    dom.addBtn.addEventListener('click', () => {
      const text = dom.textInput.value;
      const title = dom.titleInput.value;
      if (!text.trim() && !title.trim()) return;
      if (title.trim()) currentTitle = title.trim();
      if (text.trim()) {
        const newSentences = parseText(text);
        sentenceData = [...sentenceData, ...newSentences]; 
      }
      dom.textInput.value = '';
      dom.titleInput.value = '';
      saveState();
      renderReader();
    });

    function openSelectionModal(word, sIndex, sText) {
      const cleanWord = word.replace(/[^\p{L}'â€™-]/gu, '');
      currentSelection = { word: cleanWord, sentenceIndex: sIndex, sentenceText: sText };
      dom.selectedWordDisplay.textContent = cleanWord;
      dom.selectionModal.classList.add('active');
    }

    dom.btnStudyWord.addEventListener('click', async () => {
      dom.selectionModal.classList.remove('active');
      await startDeck('word');
    });

    dom.btnStudySentence.addEventListener('click', async () => {
      dom.selectionModal.classList.remove('active');
      await startDeck('sentence');
    });

    dom.closeSelection.addEventListener('click', () => dom.selectionModal.classList.remove('active'));
    dom.closeFlashcard.addEventListener('click', () => dom.flashcardModal.classList.remove('active'));

    function resetReveals() {
      dom.examplesCard.classList.remove('revealed');
      dom.pronunciationCard.classList.remove('revealed');
    }

    window.toggleReveal = function(overlayEl) {
      const card = overlayEl.closest('.special-card');
      card.classList.add('revealed');
    }

    // --- HTML CLEANING & EXTRACTION ---
    // Updated to be more robust for nested spans and "dd" tags
    function cleanAndParseDefinitions(rawHtmlOrArray) {
      let inputs = Array.isArray(rawHtmlOrArray) ? rawHtmlOrArray : [rawHtmlOrArray];
      let results = [];

      inputs.forEach(htmlStr => {
        if (!htmlStr) return;
        
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlStr;

        // 1. Look for list items (li) OR definitions (dd)
        const items = tempDiv.querySelectorAll('li, dd');

        if (items.length > 0) {
          items.forEach(item => {
            // Get innerHTML to keep spans/formatting. 
            // We use item.innerHTML so spans inside are preserved.
            const text = item.innerHTML.trim(); 
            if(text) results.push(text);
          });
        } else {
          // 2. Fallback: No list found. 
          // If the text contains <p>, use those.
          const paragraphs = tempDiv.querySelectorAll('p');
          if (paragraphs.length > 0) {
              paragraphs.forEach(p => {
                 const text = p.innerHTML.trim();
                 if(text) results.push(text);
              });
          } else {
              // 3. Absolute Fallback: It's just a blob.
              // Just return the innerHTML of the wrapper. 
              // This catches case where user just has a single <span> text.
              const text = tempDiv.innerHTML.trim();
              if (text) results.push(text);
          }
        }
      });
      
      if (results.length === 0 && inputs.length > 0) return inputs;
      return results;
    }

    async function startDeck(mode) {
      dom.flashcardModal.classList.add('active');
      dom.cardMeanings.innerHTML = '<div style="padding:2rem; text-align:center;">Loading cards...</div>';
      resetReveals(); 
      
      activeDeck.mode = mode;
      activeDeck.pointer = 0;
      activeDeck.queue = [];

      if(window.frenchWordsApi && window.frenchWordsApi.preloadFrenchWordData) {
        await window.frenchWordsApi.preloadFrenchWordData();
      }

      if (mode === 'word') {
        const cards = await generateCardsFromText(currentSelection.word);
        const exactMatches = cards.filter(c => c.display.toLowerCase() === currentSelection.word.toLowerCase());
        const otherMatches = cards.filter(c => c.display.toLowerCase() !== currentSelection.word.toLowerCase());
        
        activeDeck.queue = [...exactMatches, ...otherMatches];

        if (activeDeck.queue.length === 0) {
          activeDeck.queue.push({
            id: 'fallback', display: currentSelection.word, meanings: ['No definition found.'], found: true
          });
        }
        dom.deckLabel.textContent = "Word Study";
      } else {
        const cards = await generateCardsFromText(currentSelection.sentenceText);
        activeDeck.queue = cards;
        dom.deckLabel.textContent = "Sentence Study";
      }

      showCard(0);
    }

    async function generateCardsFromText(textStr) {
      if(!window.frenchWordsApi) return [];
      const lookup = await window.frenchWordsApi.lookupFrenchWords(textStr);
      const cards = [];
      lookup.forEach((entry, idx) => {
        cards.push({
          id: entry.word + '-' + idx,
          display: entry.word || entry.originalText,
          meanings: entry.meanings,
          category: entry.category,
          gender: entry.gender,
          pronouns: entry.pronouns,
          pronunciationIpa: entry.pronunciationIpa,
          pronunciationEnglish: entry.pronunciationEnglish,
          tense: entry.tense,
          conjugatedFrom: entry.conjugatedFrom,
          conjugatedFromMeaning: entry.conjugatedFromMeaning,
          exampleSentences: entry.exampleSentences,
          notes: entry.notes,
          found: entry.found,
          wiktionaryLookupWord: entry.word || entry.originalText,
          sentence: currentSelection.sentenceText
        });
      });
      return cards;
    }

    async function showCard(index) {
      resetReveals();
      if (index >= activeDeck.queue.length) {
        finishDeck();
        return;
      }

      const card = activeDeck.queue[index];
      dom.deckProgress.textContent = `${index + 1} / ${activeDeck.queue.length}`;
      dom.cardTerm.textContent = card.display;
      
      let sub = [];
      if(card.category) sub.push(card.category);
      if(card.gender) sub.push(card.gender);
      dom.cardSubtitle.textContent = sub.join(' â€¢ ');
      
      if (!card.found && !card.meanings) {
         dom.cardMeanings.innerHTML = 'Looking up...';
         try {
           const defs = await window.frenchWordsApi.fetchWiktionaryMeaning(card.wiktionaryLookupWord);
           card.meanings = defs || ['No definition found'];
         } catch(e) {
           card.meanings = ['Could not fetch definition.'];
         }
         card.found = true;
      }

      const cleanMeanings = cleanAndParseDefinitions(card.meanings);

      const items = [];
      const pushItem = (label, val, type='text') => {
         if(!val) return;
         if(Array.isArray(val) && val.length === 0) return;
         items.push({ label, val, type });
      };

      pushItem('Meanings', cleanMeanings, 'paged-list');
      pushItem('Category', card.category);
      pushItem('Gender', card.gender);
      pushItem('Pronouns', card.pronouns, 'text');
      pushItem('Tense', card.tense, 'text');
      pushItem('Conjugated From', card.conjugatedFrom);
      
      dom.cardMeanings.innerHTML = '';
      const grid = document.createElement('div');
      grid.className = 'mini-card-grid';
      if (items.length === 1) grid.classList.add('single-mode');

      items.forEach(item => {
         const cardEl = document.createElement('div');
         cardEl.className = 'mini-card';
         
         const inner = document.createElement('div');
         inner.className = 'mini-card-inner';
         
         const front = document.createElement('div');
         front.className = 'mini-card-face mini-card-front';
         front.innerHTML = `<strong>${item.label}</strong>`;
         
         const back = document.createElement('div');
         back.className = 'mini-card-face mini-card-back';
         
         if (item.type === 'paged-list' && Array.isArray(item.val)) {
             // Pagination Logic
             const wrapper = document.createElement('div');
             wrapper.className = 'pagination-wrapper';
             
             // Scrollable Content Area
             const contentDiv = document.createElement('div');
             contentDiv.className = 'pagination-content';
             
             // Center Alignment Wrapper
             const innerContent = document.createElement('div');
             innerContent.className = 'pagination-content-inner';
             innerContent.innerHTML = item.val[0];
             
             contentDiv.appendChild(innerContent);
             
             // Controls
             const controls = document.createElement('div');
             controls.className = 'pagination-controls';
             
             const btnPrev = document.createElement('button');
             btnPrev.className = 'pager-btn';
             btnPrev.innerHTML = 'â†';
             
             const indicator = document.createElement('span');
             indicator.textContent = `1 / ${item.val.length}`;
             
             const btnNext = document.createElement('button');
             btnNext.className = 'pager-btn';
             btnNext.innerHTML = 'â†’';
             
             controls.append(btnPrev, indicator, btnNext);
             wrapper.append(contentDiv, controls);
             
             wrapper.addEventListener('click', (e) => e.stopPropagation());
             
             let pIndex = 0;
             const updatePage = () => {
                 innerContent.innerHTML = item.val[pIndex];
                 contentDiv.scrollTop = 0;
                 indicator.textContent = `${pIndex + 1} / ${item.val.length}`;
                 btnPrev.disabled = pIndex === 0;
                 btnNext.disabled = pIndex === item.val.length - 1;
             };
             
             btnPrev.onclick = (e) => { e.stopPropagation(); if(pIndex > 0) pIndex--; updatePage(); }
             btnNext.onclick = (e) => { e.stopPropagation(); if(pIndex < item.val.length - 1) pIndex++; updatePage(); }
             
             updatePage();
             back.innerHTML = '';
             back.appendChild(wrapper);

         } else {
            back.innerHTML = `<div class="mini-card-back-content">${item.val}</div>`;
         }

         inner.appendChild(front);
         inner.appendChild(back);
         cardEl.appendChild(inner);
         cardEl.addEventListener('click', () => cardEl.classList.toggle('flipped'));
         grid.appendChild(cardEl);
      });
      
      dom.cardMeanings.appendChild(grid);

      renderExamples(card);
      renderPronunciation(card);
    }

    function renderExamples(card) {
      const container = dom.examplesContent;
      container.innerHTML = '';

      const fallbackSentence = (currentSelection.sentenceIndex !== null && sentenceData[currentSelection.sentenceIndex])
        || card.sentence || '';
      const examples = Array.isArray(card.exampleSentences) && card.exampleSentences.length
        ? card.exampleSentences
        : (fallbackSentence ? [{ french: fallbackSentence, english: null }] : []);

      if (!examples.length) {
        container.innerHTML = '<div style="color:var(--muted)">No examples available.</div>';
        return;
      }

      examples.forEach(ex => {
          const div = document.createElement('div');
          div.className = 'example-line';
          div.innerHTML = `<div class="example-fr">${ex.french || card.display}</div>` +
                          (ex.english ? `<div class="example-en">${ex.english}</div>` : '');
          container.appendChild(div);
      });
    }

    function renderPronunciation(card) {
      const hasIpa = !!card.pronunciationIpa;
      const hasEnglish = !!card.pronunciationEnglish;
      let text = card.display;
      if (hasIpa || hasEnglish) {
        const ipaPart = card.pronunciationIpa || '';
        const enPart = card.pronunciationEnglish || '';
        const separator = (hasIpa && hasEnglish) ? ' / ' : '';
        text = `${ipaPart}${separator}${enPart}`.trim();
      }
      dom.pronunciationText.textContent = text;
      dom.speakButton.onclick = (e) => {
        e.stopPropagation();
        speakText(card.display || card.word || '');
      };
    }

    function speakText(text) {
      if (!window.speechSynthesis || !text) return;
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'fr-FR';
      window.speechSynthesis.speak(utterance);
    }

    function finishDeck() {
      dom.flashcardModal.classList.remove('active');
      if (activeDeck.mode === 'sentence') {
        const key = currentSelection.sentenceText.trim().toLowerCase();
        if (!progress[key]) progress[key] = { cards: {} };
        progress[key].status = 'complete';
        saveState();
        renderReader(); 
      }
    }

    dom.gradeButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const grade = btn.dataset.grade;
        if (grade === 'again') {
          activeDeck.queue.push(activeDeck.queue[activeDeck.pointer]);
        }
        activeDeck.pointer++;
        showCard(activeDeck.pointer);
      });
    });

    renderReader();
  </script>
</body>
</html>
