<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>French Study Dashboard (Gemini)</title>
  
  <!-- Typography -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Playfair+Display:ital,wght@0,600;0,700;1,400&display=swap" rel="stylesheet">

  <style>
    :root {
      /* Palette: Academic Paper */
      --bg-body: #F9F7F2;
      --bg-card: #FFFFFF;
      --bg-inset: #F2F0EB;
      
      --text-main: #2C3E50;
      --text-muted: #95a5a6;
      --text-accent: #C0392B; /* Terracotta */
      
      --primary: #2C3E50;
      --primary-hover: #1a252f;
      
      --border: #E0DED8;
      
      --shadow-soft: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03);
      --shadow-float: 0 10px 15px -3px rgba(0, 0, 0, 0.05), 0 4px 6px -2px rgba(0, 0, 0, 0.025);
      
      --radius-sm: 6px;
      --radius-md: 12px;
      --radius-lg: 16px;
    }

    * { box-sizing: border-box; outline-color: var(--primary); }
    
    body {
      margin: 0;
      background-color: var(--bg-body);
      color: var(--text-main);
      font-family: 'Inter', sans-serif;
      line-height: 1.6;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    /* --- Header --- */
    header {
      background: var(--bg-card);
      border-bottom: 1px solid var(--border);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .brand h1 {
      font-family: 'Playfair Display', serif;
      font-size: 1.4rem;
      font-weight: 700;
      margin: 0;
      color: var(--primary);
    }
    .brand small { color: var(--text-muted); font-size: 0.85rem; }

    header a {
      font-size: 0.9rem;
      color: var(--primary);
      text-decoration: none;
      font-weight: 500;
    }
    header a:hover { color: var(--text-accent); }

    /* --- Layout --- */
    main {
      flex: 1;
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
      width: 100%;
      display: grid;
      grid-template-columns: 320px 1fr;
      gap: 2rem;
      align-items: start;
    }

    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; padding: 1rem; }
    }

    /* --- Sidebar --- */
    .sidebar {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      padding: 1.5rem;
      box-shadow: var(--shadow-soft);
      position: sticky;
      top: 90px;
    }

    h2 {
      font-family: 'Playfair Display', serif;
      font-size: 1.15rem;
      margin-top: 0;
      margin-bottom: 1rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid var(--bg-inset);
    }

    textarea, input[type="text"], input[type="password"] {
      width: 100%;
      background: var(--bg-inset);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      padding: 10px;
      font-family: 'Inter', sans-serif;
      font-size: 0.85rem;
      color: var(--text-main);
    }
    textarea { min-height: 120px; resize: vertical; }
    textarea:focus, input:focus { border-color: var(--primary); background: #fff; }

    fieldset {
      border: 0;
      background: var(--bg-inset);
      border-radius: var(--radius-sm);
      padding: 0.75rem;
      margin: 1rem 0;
    }
    
    legend {
      font-weight: 600;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    label { display: block; margin-bottom: 0.4rem; font-size: 0.85rem; }
    
    input[type="number"], select {
      background: #fff;
      border: 1px solid var(--border);
      padding: 4px 8px;
      border-radius: 4px;
      font-family: inherit;
      font-size: 0.9rem;
    }

    .btn-group { display: flex; gap: 8px; margin-top: 1rem; }
    
    button {
      flex: 1;
      padding: 10px 16px;
      border: 1px solid var(--primary);
      border-radius: var(--radius-sm);
      font-family: 'Inter', sans-serif;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    button.primary {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 2px 4px rgba(44, 62, 80, 0.2);
    }
    button.primary:hover { background: var(--primary-hover); transform: translateY(-1px); }
    button.primary:disabled { background: var(--text-muted); border-color: var(--text-muted); opacity: 0.7; transform: none; cursor: not-allowed; }

    button.secondary { background: #fff; color: var(--primary); }
    button.secondary:hover { background: var(--bg-inset); }

    .meta-display {
      margin-top: 1rem;
      font-size: 0.8rem;
      color: var(--text-muted);
      border-top: 1px solid var(--border);
      padding-top: 1rem;
    }
    
    .api-section {
      margin-bottom: 1.5rem;
      border-bottom: 1px solid var(--border);
      padding-bottom: 1rem;
    }

    /* --- Dashboard --- */
    .dashboard {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
    }

    .deck-stats {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .stat-pill {
      background: var(--bg-card);
      border: 1px solid var(--border);
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
      box-shadow: var(--shadow-soft);
    }
    .stat-pill span { color: var(--text-muted); font-weight: 400; margin-right: 4px; }

    /* --- STATIC STUDY CARD --- */
    .static-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-float);
      padding: 3rem;
      min-height: 500px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    .card-header {
      text-align: center;
      margin-bottom: 3rem;
      border-bottom: 2px solid var(--bg-inset);
      width: 100%;
      padding-bottom: 2rem;
    }
    
    .headword {
      font-family: 'Playfair Display', serif;
      font-size: 4.5rem;
      font-weight: 700;
      color: var(--primary);
      margin: 0;
      line-height: 1.1;
    }
    
    .sub-headword {
      font-family: 'Inter', sans-serif;
      font-size: 1.1rem;
      color: var(--text-accent);
      margin-top: 0.5rem;
      font-style: italic;
    }

    /* Mini Grid */
    .mini-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1.5rem;
      width: 100%;
      flex: 1;
    }

    @media (max-width: 768px) {
      .mini-grid { grid-template-columns: 1fr; }
      .static-card { padding: 1.5rem; }
      .headword { font-size: 3rem; }
    }

    /* --- MINI FLIP CARDS --- */
    .mini-card {
      position: relative;
      background: transparent;
      perspective: 1000px;
      cursor: pointer;
      height: 220px;
    }

    .mini-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1);
      transform-style: preserve-3d;
      border: 1px solid var(--border);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-soft);
      background: var(--bg-body);
    }

    .mini-card.flipped .mini-inner {
      transform: rotateY(180deg);
    }
    
    /* Loading / Pulse State */
    .mini-card.loading {
      cursor: wait;
    }
    .mini-card.loading .mini-inner {
      background: linear-gradient(90deg, #F2F0EB 25%, #fff 50%, #F2F0EB 75%);
      background-size: 200% 100%;
      animation: pulse 1.5s infinite;
      border-color: transparent;
    }
    @keyframes pulse {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }

    /* Faces */
    .mini-face {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      border-radius: var(--radius-md);
    }

    .mini-face.mini-front {
      background: #FFFFFF;
      align-items: center;
      justify-content: center;
      text-align: center;
    }
    
    .mini-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.15em;
      color: var(--text-muted);
      font-weight: 600;
      margin-bottom: 1rem;
    }
    
    .mini-icon {
      font-size: 2.5rem;
      color: var(--primary);
      margin-bottom: 1rem;
      opacity: 0.8;
    }
    
    .mini-hint {
      font-size: 0.75rem;
      color: var(--text-accent);
      font-weight: 500;
    }

    .mini-face.mini-back {
      background: #FFF;
      transform: rotateY(180deg);
      overflow-y: auto;
      border: 1px solid var(--primary);
      align-items: flex-start;
      text-align: left;
    }
    
    .mini-back-title {
      font-size: 0.7rem;
      text-transform: uppercase;
      color: var(--text-accent);
      margin-bottom: 0.5rem;
      font-weight: 700;
      letter-spacing: 0.05em;
    }

    .mini-content {
      font-size: 0.95rem;
      color: var(--text-main);
      line-height: 1.6;
    }
    
    .pill {
      display: inline-block;
      font-size: 0.8rem;
      background: var(--bg-inset);
      padding: 4px 8px;
      border-radius: 6px;
      color: var(--text-main);
      margin-right: 6px;
      margin-bottom: 6px;
      font-family: monospace;
      border: 1px solid var(--border);
    }

    .mini-face::-webkit-scrollbar { width: 4px; }
    .mini-face::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

    .controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 2rem;
      flex-wrap: wrap;
    }

    .controls button {
      min-width: 140px;
      padding: 14px 28px;
      font-size: 1rem;
      font-weight: 600;
    }

    .grades {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 10px;
      margin-top: 1.5rem;
    }

    .deck-picker {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .deck-picker label {
      margin: 0;
      font-weight: 600;
      font-size: 0.9rem;
      color: var(--text-main);
    }

    .deck-picker select {
      min-width: 220px;
    }

    .grade-btn {
      border: none;
      padding: 12px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      color: #0b1120;
    }

    .grade-again { background: #f87171; }
    .grade-hard { background: #fbbf24; }
    .grade-medium { background: #34d399; }
    .grade-easy { background: #60a5fa; }
    .grade-good { background: #a78bfa; }

    .pron-actions {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .speaker-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--bg-inset);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 0.85rem;
      color: var(--primary);
    }
    .speaker-btn:hover { background: #fff; }

    .status-text {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.9rem;
      margin-top: 1rem;
      font-style: italic;
    }
  </style>
</head>
<body>

  <header>
    <div class="brand">
      <h1>L'√âtude Fran√ßais</h1>
      <small>Powered by Gemini AI</small>
    </div>
    <a href="./index.html">Main Menu</a>
  </header>

  <main>
    <!-- LEFT: Settings & Input -->
    <section class="sidebar">
      
      <!-- API Key Section -->
      <div class="api-section">
        <label for="apiKey">Google AI Studio API Key</label>
        <div style="display:flex; gap:6px; margin-top:6px;">
          <input type="password" id="apiKey" placeholder="AIza..." />
          <button id="saveKey" class="secondary" style="flex:0 0 auto;">Save</button>
        </div>
        <div style="font-size:0.75rem; color:var(--text-muted); margin-top:4px;">Key is stored locally in your browser.</div>
      </div>

      <h2>1. Source Text</h2>
      <label for="wordInput">Paste French text below:</label>
      <textarea id="wordInput" placeholder="Paste article or book excerpt here..."></textarea>
      
      <fieldset>
        <legend>Filters</legend>
        <label><input type="checkbox" id="removeDuplicates" checked /> Unique words only</label>
        
        <div style="margin-top:10px;">
          <label style="margin-bottom:4px; display:block;">Frequency filter:</label>
          <div style="display:flex; gap:8px; align-items:center;">
            <select id="underOverMode" style="flex:1;">
              <option value="none">All words</option>
              <option value="under">Occurs under</option>
              <option value="over">Occurs over</option>
              <option value="range">Outside range</option>
            </select>
            <input type="number" id="threshold" min="1" placeholder="N" style="width:60px;" />
          </div>
          <div id="rangeExtras" style="display:none; margin-top:8px; gap:4px; align-items:center;">
             <span style="font-size:0.8rem;">Min:</span>
             <input type="number" id="minOcc" min="1" style="width:50px;" />
             <span style="font-size:0.8rem;">Max:</span>
             <input type="number" id="maxOcc" min="1" style="width:50px;" />
          </div>
        </div>
      </fieldset>

      <div class="btn-group">
        <button id="processBtn" class="primary">Process Text</button>
        <button id="clearBtn" class="secondary">Reset</button>
      </div>

      <div class="meta-display">
        <div id="summary">Waiting for input...</div>
        <div style="margin-top:10px;">
          <label style="display:block; margin-bottom:5px;">Filtered List:</label>
          <textarea id="processedWords" readonly style="min-height:80px; font-family:monospace; color:var(--text-muted);"></textarea>
        </div>
        <div id="cacheInfo" style="margin-top:5px; font-size:0.75rem;"></div>
      </div>
    </section>

    <!-- RIGHT: Dashboard -->
    <section class="dashboard">
      <div class="deck-stats">
        <div class="stat-pill"><span>Deck:</span><strong id="deckBadge">0/0</strong></div>
        <div class="stat-pill"><span>Left:</span><strong id="queueBadge">0</strong></div>
        <div class="stat-pill"><span>Cached:</span><strong id="cachedCount">0</strong></div>
      </div>

      <div class="static-card">
        <div class="card-header">
          <h1 class="headword" id="headwordDisplay">Bonjour</h1>
          <div class="sub-headword" id="posDisplay">Start here</div>
        </div>

        <!-- Mini Cards Grid -->
        <div class="mini-grid" id="miniGrid">
          <div style="grid-column: 1 / -1; text-align:center; color:var(--text-muted);">
            Enter text and API key, then click 'Start Deck'.
          </div>
        </div>
      </div>
      
      <!-- Controls -->
      <div class="controls">
        <button id="startDeck" class="primary" disabled>Start Deck</button>
        <button id="shuffleDeck" class="secondary" disabled>Shuffle</button>
        <button id="nextCard" class="primary" disabled>Next Word ‚Üí</button>
      </div>

      <div class="deck-picker">
        <label for="deckPicker">Choose deck:</label>
        <select id="deckPicker" disabled>
          <option>No decks available</option>
        </select>
      </div>

      <div class="grades" id="gradeRow" style="display:none;">
        <button class="grade-btn grade-again" data-offset="2" data-action="again">Again</button>
        <button class="grade-btn grade-hard" data-offset="5" data-action="hard">Hard</button>
        <button class="grade-btn grade-medium" data-offset="10" data-action="medium">Medium</button>
        <button class="grade-btn grade-easy" data-offset="15" data-action="easy">Easy</button>
        <button class="grade-btn grade-good" data-offset="remove" data-action="good">Good</button>
      </div>

      <div class="status-text" id="status">Ready.</div>
      
      <!-- Hidden Logic Elements (kept for JS ref) -->
      <div style="display:none;">
        <span id="deckSize"></span>
        <span id="remaining"></span>
        <span id="wordTotal"></span>
      </div>

    </section>
  </main>

  <script>
    const STORAGE_KEY = 'french-wordlist-gemini-state-v1';
    const API_KEY_STORAGE = 'frenchWordlistGeminiKey';
    const MAX_DECK = 25;

    const geminiSystemInstruction = `I will write a FRENCH word and i want the definition of word 
and IPA and english pronuncation as well, and an English translation of the sentence in brackets:
[fl√¢neur <m> (noun) ///fl…ë.n≈ì Å/// +++flah-nur+++ | an aimless wanderer or stroller | Le fl√¢neur observait la ville sans se presser. (The stroller watched the city without hurrying.)]`;

    const dom = {
      wordInput: document.getElementById('wordInput'),
      processedWords: document.getElementById('processedWords'),
      summary: document.getElementById('summary'),
      cacheInfo: document.getElementById('cacheInfo'),
      processBtn: document.getElementById('processBtn'),
      clearBtn: document.getElementById('clearBtn'),
      startDeckBtn: document.getElementById('startDeck'),
      nextCardBtn: document.getElementById('nextCard'),
      shuffleBtn: document.getElementById('shuffleDeck'),
      status: document.getElementById('status'),
      deckSize: document.getElementById('deckSize'),
      remaining: document.getElementById('remaining'),
      deckBadge: document.getElementById('deckBadge'),
      queueBadge: document.getElementById('queueBadge'),
      cachedCount: document.getElementById('cachedCount'),
      wordTotal: document.getElementById('wordTotal'),
      gradeRow: document.getElementById('gradeRow'),
      deckPicker: document.getElementById('deckPicker'),

      headwordDisplay: document.getElementById('headwordDisplay'),
      posDisplay: document.getElementById('posDisplay'),
      miniGrid: document.getElementById('miniGrid'),
      
      removeDuplicates: document.getElementById('removeDuplicates'),
      modeSelect: document.getElementById('underOverMode'),
      threshold: document.getElementById('threshold'),
      minOcc: document.getElementById('minOcc'),
      maxOcc: document.getElementById('maxOcc'),
      rangeExtras: document.getElementById('rangeExtras'),
      apiKey: document.getElementById('apiKey'),
      saveKey: document.getElementById('saveKey'),
    };

    const state = {
      countMap: new Map(),
      filteredKeys: [],
      definitions: {},
      queue: [],
      deckSize: 0,
      completed: 0,
      currentWord: null,
      totalWords: 0,
      sentenceCount: 0,
      selectedDeckIndex: 0,
    };

    const pendingDefinitions = new Map();

    // --- storage helpers ---
    function persistState() {
      const payload = {
        inputText: dom.wordInput.value,
        filteredKeys: state.filteredKeys,
        definitions: state.definitions,
        settings: {
          removeDuplicates: dom.removeDuplicates.checked,
          mode: dom.modeSelect.value,
          threshold: dom.threshold.value,
          minOcc: dom.minOcc.value,
          maxOcc: dom.maxOcc.value,
        },
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }

    function loadState() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        if (data.inputText) dom.wordInput.value = data.inputText;
        if (data.settings) {
          dom.removeDuplicates.checked = !!data.settings.removeDuplicates;
          dom.modeSelect.value = data.settings.mode || 'none';
          dom.threshold.value = data.settings.threshold || '';
          dom.minOcc.value = data.settings.minOcc || '';
          dom.maxOcc.value = data.settings.maxOcc || '';
        }
        state.filteredKeys = Array.isArray(data.filteredKeys) ? data.filteredKeys : [];
        state.definitions = data.definitions || {};
      } catch (err) { console.error('Load state failed', err); }
    }

    function loadApiKey() {
      const saved = localStorage.getItem(API_KEY_STORAGE);
      if (saved) dom.apiKey.value = saved;
      return dom.apiKey.value.trim();
    }

    function saveApiKey() {
      const val = dom.apiKey.value.trim();
      if (!val) return;
      localStorage.setItem(API_KEY_STORAGE, val);
      dom.status.textContent = 'API key saved locally.';
      setTimeout(() => dom.status.textContent = '', 2000);
    }

    // --- text processing ---
    function normaliseWord(raw) { return raw.trim().toLowerCase(); }
    function splitTextToSentences(text) {
      if (!text) return [];
      const normalised = text.replace(/\s+/g, ' ').trim();
      if (!normalised) return [];
      const matches = normalised.match(/[^.!?]+[.!?]*/g);
      if (!matches) return [];
      return matches.map(s => s.trim()).filter(Boolean);
    }
    function sentenceToWords(sentence) {
      const cleaned = sentence.replace(/[^A-Za-z√Ä-√ñ√ò-√∂√∏-√ø≈ì≈í'-]+/g, ' ');
      return cleaned.split(/\s+/).map(w => w.trim()).filter(w => w.length > 0);
    }
    function buildCountMapFromText(inputText) {
      const sentences = splitTextToSentences(inputText);
      const map = new Map();
      let totalWords = 0;
      for (const sentence of sentences) {
        const words = sentenceToWords(sentence);
        for (const rawWord of words) {
          const key = normaliseWord(rawWord);
          if (!key) continue;
          totalWords++;
          const existing = map.get(key);
          if (existing) existing.count += 1; else map.set(key, { original: rawWord, count: 1 });
        }
      }
      return { map, totalWords, sentenceCount: sentences.length };
    }

    function applyFilters(countMap) {
      const mode = dom.modeSelect.value;
      const removeDuplicates = dom.removeDuplicates.checked;
      let thresholdVal = parseInt(dom.threshold.value, 10);
      if (Number.isNaN(thresholdVal)) thresholdVal = null;
      let minOcc = parseInt(dom.minOcc.value, 10);
      let maxOcc = parseInt(dom.maxOcc.value, 10);
      if (Number.isNaN(minOcc)) minOcc = null;
      if (Number.isNaN(maxOcc)) maxOcc = null;

      const filteredKeys = [];
      const processedLines = [];
      for (const [key, info] of countMap.entries()) {
        const count = info.count;
        let keep = true;
        if (mode === 'under' && thresholdVal != null && count < thresholdVal) keep = false;
        else if (mode === 'over' && thresholdVal != null && count > thresholdVal) keep = false;
        else if (mode === 'range') {
          if (minOcc != null && count < minOcc) keep = false;
          if (maxOcc != null && count > maxOcc) keep = false;
        }
        if (!keep) continue;
        filteredKeys.push(key);
        if (removeDuplicates) processedLines.push(info.original);
        else { for (let i = 0; i < count; i++) processedLines.push(info.original); }
      }
      return { filteredKeys, processedLines };
    }

    function updateRangeExtras() {
      dom.rangeExtras.style.display = dom.modeSelect.value === 'range' ? 'inline' : 'none';
    }

    function updateSummary() {
      dom.summary.textContent = `${state.filteredKeys.length} filtered words.`;
      dom.wordTotal.textContent = state.filteredKeys.length;
      dom.cacheInfo.textContent = `Cached: ${Object.keys(state.definitions || {}).length}`;
      dom.cachedCount.textContent = `${Object.keys(state.definitions || {}).length}`;
    }

    function refreshDeckPicker() {
      dom.deckPicker.innerHTML = '';
      const total = state.filteredKeys.length;
      if (!total) {
        dom.deckPicker.innerHTML = '<option>No decks available</option>';
        dom.deckPicker.disabled = true;
        dom.startDeckBtn.disabled = true;
        return;
      }

      const deckCount = Math.ceil(total / MAX_DECK);
      state.selectedDeckIndex = Math.min(state.selectedDeckIndex, deckCount - 1);

      for (let i = 0; i < deckCount; i++) {
        const start = i * MAX_DECK;
        const end = Math.min(start + MAX_DECK, total);
        const firstWord = state.filteredKeys[start] || '‚Äî';
        const lastWord = state.filteredKeys[end - 1] || '‚Äî';
        const option = document.createElement('option');
        option.value = i;
        option.textContent = `Deck ${i + 1}: ${firstWord} - ${lastWord}`;
        dom.deckPicker.appendChild(option);
      }

      dom.deckPicker.disabled = false;
      dom.deckPicker.value = `${state.selectedDeckIndex}`;
      dom.startDeckBtn.disabled = false;
    }

    function processText() {
      const input = dom.wordInput.value || '';
      const { map, totalWords, sentenceCount } = buildCountMapFromText(input);
      state.countMap = map;
      state.totalWords = totalWords;
      state.sentenceCount = sentenceCount;
      const { filteredKeys, processedLines } = applyFilters(map);
      state.filteredKeys = filteredKeys;
      state.selectedDeckIndex = 0;
      dom.processedWords.value = processedLines.join('\n');
      dom.startDeckBtn.disabled = !filteredKeys.length;

      dom.deckBadge.textContent = '0/0';
      dom.queueBadge.textContent = '0';

      updateSummary();
      refreshDeckPicker();
      persistState();
    }

    // --- Gemini helpers ---
    function parseGeminiFlashcards(text, originalTerm) {
      const matches = Array.from(text.matchAll(/\[(.*?)\]/gs)).map(m => m[1]);
      if (!matches.length) throw new Error('AI Parse Error. Try again.');
      return matches.map((entry, idx) => {
        let ipa = '';
        let phonetic = '';
        const ipaMatch = entry.match(/\/\/\/(.*?)\/\/\//);
        if (ipaMatch) { ipa = ipaMatch[1]; entry = entry.replace(ipaMatch[0], ''); }
        const phoneMatch = entry.match(/\+\+\+(.*?)\+\+\+/);
        if (phoneMatch) { phonetic = phoneMatch[1]; entry = entry.replace(phoneMatch[0], ''); }
        const parts = entry.split('|').map(p => p.trim()).filter(Boolean);
        const head = parts[0] || '';
        const meaning = parts[1] || '';
        const example = parts[2] || '';
        const genderMatch = head.match(/<(.*?)>/);
        const posMatch = head.match(/\((.*?)\)/);
        const term = head.replace(/<.*?>/g, '').replace(/\(.*?\)/g, '').trim() || `${originalTerm}-${idx + 1}`;
        return { 
          id: Date.now() + idx, 
          term, 
          ipa, 
          phonetic, 
          pos: posMatch ? posMatch[1] : '', 
          definitions: [{ text: meaning || 'Definition unavailable', example }], 
          gender: genderMatch ? genderMatch[1] : '' 
        };
      });
    }

    async function fetchGeminiDefinition(term) {
      const apiKey = dom.apiKey.value.trim() || loadApiKey();
      if (!apiKey) throw new Error('API Key Missing.');
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-lite-latest:generateContent?key=${apiKey}`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({
          systemInstruction: { parts: [{ text: geminiSystemInstruction }] }, contents: [{ parts: [{ text: term }] }]
        })
      });
      const responseText = await response.text();
      let data = null;
      try { data = JSON.parse(responseText); } catch (_) { data = null; }
      if (!response.ok || data?.error) {
        const err = new Error(data?.error?.message || `Request failed with status ${response.status}`);
        err.rawResponse = responseText || response.statusText;
        throw err;
      }
      const botText = data?.candidates?.[0]?.content?.parts?.[0]?.text;
      if (!botText) throw new Error('No content returned.');
      const cards = parseGeminiFlashcards(botText, term);
      return cards[0];
    }

    function buildErrorDetails(err) {
      const wrapper = document.createElement('div');
      wrapper.style.gridColumn = '1 / -1';
      wrapper.style.textAlign = 'center';
      wrapper.style.color = 'var(--text-accent)';
      wrapper.style.display = 'flex';
      wrapper.style.flexDirection = 'column';
      wrapper.style.gap = '12px';

      const message = document.createElement('div');
      message.textContent = `Error: ${err?.message || 'Unknown error'}`;
      wrapper.appendChild(message);

      if (err?.rawResponse) {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = 'See API response';
        const pre = document.createElement('pre');
        pre.style.textAlign = 'left';
        pre.style.whiteSpace = 'pre-wrap';
        pre.textContent = err.rawResponse;
        details.appendChild(summary);
        details.appendChild(pre);
        wrapper.appendChild(details);
      }

      const skipBtn = document.createElement('button');
      skipBtn.className = 'secondary';
      skipBtn.style.alignSelf = 'center';
      skipBtn.textContent = 'Skip this card';
      skipBtn.addEventListener('click', () => {
        skipCurrentCard();
      });
      wrapper.appendChild(skipBtn);

      return wrapper;
    }

    // --- Rendering Logic ---

    function createMiniCard(label, icon, content) {
      const card = document.createElement('div');
      card.className = 'mini-card';
      
      const inner = document.createElement('div');
      inner.className = 'mini-inner';
      
      // Front
      const front = document.createElement('div');
      front.className = 'mini-face mini-front';
      front.innerHTML = `
        <div class="mini-label">${label}</div>
        <div class="mini-icon">${icon}</div>
        <div class="mini-hint">Click to Reveal</div>
      `;
      
      // Back
      const back = document.createElement('div');
      back.className = 'mini-face mini-back';
      
      const backTitle = document.createElement('div');
      backTitle.className = 'mini-back-title';
      backTitle.textContent = label;
      
      const backContent = document.createElement('div');
      backContent.className = 'mini-content';
      
      // Allow HTML in content (for pills etc)
      if(typeof content === 'string') backContent.innerHTML = content;
      else backContent.appendChild(content);
      
      back.appendChild(backTitle);
      back.appendChild(backContent);
      
      inner.appendChild(front);
      inner.appendChild(back);
      card.appendChild(inner);
      
      card.addEventListener('click', (event) => {
        if (event.target.closest('.speaker-btn')) return;
        card.classList.toggle('flipped');
      });
      
      return card;
    }

    function createLoadingCard(label, icon) {
      const card = document.createElement('div');
      card.className = 'mini-card loading';
      
      const inner = document.createElement('div');
      inner.className = 'mini-inner';
      
      const front = document.createElement('div');
      front.className = 'mini-face mini-front';
      front.innerHTML = `
        <div class="mini-label">${label}</div>
        <div class="mini-icon" style="opacity:0.5;">${icon}</div>
        <div class="mini-hint">Fetching AI...</div>
      `;
      
      inner.appendChild(front);
      card.appendChild(inner);
      return card;
    }

    function renderLoadingState(word) {
      dom.headwordDisplay.textContent = word;
      dom.posDisplay.textContent = 'Fetching data...';
      dom.miniGrid.innerHTML = '';
      dom.miniGrid.appendChild(createLoadingCard('Meaning', 'üìñ'));
      dom.miniGrid.appendChild(createLoadingCard('Pronounce', 'üó£Ô∏è'));
      dom.miniGrid.appendChild(createLoadingCard('Context', 'üí¨'));
      dom.miniGrid.appendChild(createLoadingCard('Gender', '‚ößÔ∏è'));
    }

    function renderDefinition(word) {
      const entry = state.definitions[word];
      if (!entry || entry.error) {
        dom.headwordDisplay.textContent = entry?.term || word;
        dom.posDisplay.textContent = 'API Error';
        dom.miniGrid.innerHTML = '';
        dom.miniGrid.appendChild(buildErrorDetails({ message: entry?.error || 'Error', rawResponse: entry?.rawResponse }));
        return;
      }

      dom.headwordDisplay.textContent = entry.term || word;
      dom.posDisplay.textContent = 'Flip the cards to reveal grammar details.';

      const defs = entry.definitions || [];
      const first = defs[0] || {};
      const meaningText = first.text || '‚Äî';
      const exampleText = first.example || '‚Äî';

      // Phonetics UI
      const pronWrapper = document.createElement('div');
      if (entry.ipa) {
        const ipaPill = document.createElement('span');
        ipaPill.className = 'pill';
        ipaPill.textContent = `/${entry.ipa}/`;
        pronWrapper.appendChild(ipaPill);
      }
      if (entry.phonetic) {
        const phonePill = document.createElement('span');
        phonePill.className = 'pill';
        phonePill.textContent = entry.phonetic;
        pronWrapper.appendChild(phonePill);
      }
      if (!entry.ipa && !entry.phonetic) {
        pronWrapper.textContent = 'No pronunciation data.';
      }

      const pronActions = document.createElement('div');
      pronActions.className = 'pron-actions';

      const speakWordBtn = document.createElement('button');
      speakWordBtn.type = 'button';
      speakWordBtn.className = 'speaker-btn';
      speakWordBtn.innerHTML = 'üîä Speak word';
      speakWordBtn.addEventListener('click', () => speak(entry.term || word));

      const speakIpaBtn = document.createElement('button');
      speakIpaBtn.type = 'button';
      speakIpaBtn.className = 'speaker-btn';
      speakIpaBtn.innerHTML = 'üó£Ô∏è Speak IPA';
      speakIpaBtn.addEventListener('click', () => speak(entry.ipa || entry.phonetic || entry.term || word));

      pronActions.appendChild(speakWordBtn);
      pronActions.appendChild(speakIpaBtn);
      pronWrapper.appendChild(pronActions);

      const contextWrapper = document.createElement('div');
      const exampleParagraph = document.createElement('div');
      exampleParagraph.textContent = exampleText;
      contextWrapper.appendChild(exampleParagraph);

      if (exampleText && exampleText !== '‚Äî') {
        const exampleActions = document.createElement('div');
        exampleActions.className = 'pron-actions';

        const speakExampleBtn = document.createElement('button');
        speakExampleBtn.type = 'button';
        speakExampleBtn.className = 'speaker-btn';
        speakExampleBtn.innerHTML = 'üîà Speak example';
        const exampleSpeech = exampleText.replace(/\s*[\(\[].*?[\)\]]\s*$/, '').trim() || exampleText;
        speakExampleBtn.addEventListener('click', () => speak(exampleSpeech));

        exampleActions.appendChild(speakExampleBtn);
        contextWrapper.appendChild(exampleActions);
      }

      const meaningWrapper = document.createElement('div');
      const meaningParagraph = document.createElement('div');
      meaningParagraph.textContent = meaningText;
      meaningWrapper.appendChild(meaningParagraph);

      const posRow = document.createElement('div');
      posRow.style.marginTop = '10px';
      const posLabel = document.createElement('span');
      posLabel.style.fontSize = '0.85rem';
      posLabel.style.color = 'var(--text-muted)';
      posLabel.textContent = 'Part of speech:';
      const posPill = document.createElement('span');
      posPill.className = 'pill';
      posPill.style.marginLeft = '8px';
      posPill.textContent = entry.pos || '‚Äî';
      posRow.appendChild(posLabel);
      posRow.appendChild(posPill);
      meaningWrapper.appendChild(posRow);

      const genderWrapper = document.createElement('div');
      const genderPill = document.createElement('span');
      genderPill.className = 'pill';
      genderPill.textContent = entry.gender || '‚Äî';
      genderWrapper.appendChild(genderPill);

      dom.miniGrid.innerHTML = '';
      dom.miniGrid.appendChild(createMiniCard('Meaning', 'üìñ', meaningWrapper));
      dom.miniGrid.appendChild(createMiniCard('Pronounce', 'üó£Ô∏è', pronWrapper));
      dom.miniGrid.appendChild(createMiniCard('Context', 'üí¨', contextWrapper));
      dom.miniGrid.appendChild(createMiniCard('Gender', '‚ößÔ∏è', genderWrapper));
    }

    async function ensureDefinition(word) {
      if (state.definitions[word]) {
        renderDefinition(word);
        return state.definitions[word];
      }

      if (pendingDefinitions.has(word)) {
        renderLoadingState(word);
        await pendingDefinitions.get(word);
        renderDefinition(word);
        return state.definitions[word];
      }

      renderLoadingState(word);

      const promise = (async () => {
        try {
          const def = await fetchGeminiDefinition(word);
          state.definitions[word] = def;
          renderDefinition(word);
          persistState();
          updateSummary();
        } catch (err) {
          console.error(err);
          state.definitions[word] = { error: err.message, rawResponse: err.rawResponse };
          dom.headwordDisplay.textContent = word;
          dom.posDisplay.textContent = 'API Error';
          dom.miniGrid.innerHTML = '';
          dom.miniGrid.appendChild(buildErrorDetails(state.definitions[word]));
          persistState();
        } finally {
          pendingDefinitions.delete(word);
        }
      })();

      pendingDefinitions.set(word, promise);
      await promise;
      return state.definitions[word];
    }

    // --- Flashcard Flow ---
    function resetDeckUi() {
      dom.headwordDisplay.textContent = 'Bonjour';
      dom.posDisplay.textContent = 'Start here';
      dom.miniGrid.innerHTML = `<div style="grid-column: 1 / -1; text-align:center; color:var(--text-muted);">Process text to begin.</div>`;
      dom.deckBadge.textContent = '0/0';
      dom.queueBadge.textContent = '0';
      dom.startDeckBtn.disabled = true;
      dom.nextCardBtn.disabled = true;
      dom.shuffleBtn.disabled = true;
      dom.gradeRow.style.display = 'none';
      dom.deckPicker.innerHTML = '<option>No decks available</option>';
      dom.deckPicker.disabled = true;
    }

    function startDeck() {
      if (!state.filteredKeys.length) return;
      const startIndex = state.selectedDeckIndex * MAX_DECK;
      const deckSlice = state.filteredKeys.slice(startIndex, startIndex + MAX_DECK);
      state.queue = deckSlice;
      state.deckSize = state.queue.length;
      state.completed = 0;
      dom.startDeckBtn.disabled = false;
      dom.nextCardBtn.disabled = false;
      dom.shuffleBtn.disabled = false;
      dom.gradeRow.style.display = 'grid';
      showCard();
    }

    function showCard() {
      if (!state.queue.length) {
        dom.headwordDisplay.textContent = 'Finished';
        dom.posDisplay.textContent = 'Deck Complete';
        dom.miniGrid.innerHTML = `<div style="grid-column:1/-1; text-align:center;">Great job!</div>`;
        dom.queueBadge.textContent = '0';
        dom.nextCardBtn.disabled = true;
        dom.shuffleBtn.disabled = true;
        dom.gradeRow.style.display = 'none';
        return;
      }
      const word = state.queue[0];
      state.currentWord = word;

      const seenCount = state.deckSize ? Math.min(state.completed + 1, state.deckSize) : 1;
      dom.deckBadge.textContent = `${seenCount}/${state.deckSize || state.queue.length}`;
      dom.queueBadge.textContent = `${Math.max(0, state.queue.length - 1)}`;

      ensureDefinition(word);
    }

    function nextCard() {
      if (!state.queue.length) return;
      state.queue.shift();
      state.completed += 1;
      showCard();
    }

    function skipCurrentCard() {
      nextCard();
    }

    function shuffleDeck(keepCurrent = true) {
      if (state.queue.length <= 1) return;
      const working = keepCurrent ? state.queue.slice(1) : state.queue.slice();
      for (let i = working.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [working[i], working[j]] = [working[j], working[i]];
      }
      state.queue = keepCurrent ? [state.queue[0], ...working] : working;
      showCard();
      dom.status.textContent = 'Deck shuffled.';
      setTimeout(() => dom.status.textContent = '', 1500);
    }

    async function gradeCard(action, offset) {
      if (!state.queue.length) return;
      const word = state.queue[0];
      await ensureDefinition(word);
      state.queue.shift();
      if (offset !== 'remove') {
        const position = Math.min(state.queue.length, offset);
        state.queue.splice(position, 0, word);
      }
      state.completed += 1;
      dom.status.textContent = `Marked ${action}.`;
      setTimeout(() => dom.status.textContent = '', 1200);
      showCard();
    }

    function clearAll() {
      dom.wordInput.value = '';
      dom.processedWords.value = '';
      dom.summary.textContent = 'Cleared.';
      dom.cacheInfo.textContent = '';
      state.filteredKeys = [];
      state.definitions = {};
      state.queue = [];
      state.deckSize = 0;
      state.completed = 0;
      persistState();
      resetDeckUi();
    }

    function speak(text) {
      if (!text || !('speechSynthesis' in window)) return;
      const utter = new SpeechSynthesisUtterance(text);
      utter.lang = 'fr-FR';
      utter.rate = 0.95;
      window.speechSynthesis.speak(utter);
    }

    // --- Events ---
    dom.processBtn.addEventListener('click', processText);
    dom.clearBtn.addEventListener('click', clearAll);
    dom.startDeckBtn.addEventListener('click', startDeck);
    dom.nextCardBtn.addEventListener('click', nextCard);
    dom.shuffleBtn.addEventListener('click', () => shuffleDeck(true));
    dom.gradeRow.addEventListener('click', (e) => {
      const btn = e.target.closest('.grade-btn');
      if (!btn) return;
      const offset = btn.dataset.offset === 'remove' ? 'remove' : parseInt(btn.dataset.offset, 10);
      gradeCard(btn.dataset.action, offset);
    });
    
    dom.modeSelect.addEventListener('change', () => { updateRangeExtras(); processText(); });
    dom.threshold.addEventListener('input', processText);
    dom.minOcc.addEventListener('input', processText);
    dom.maxOcc.addEventListener('input', processText);
    dom.removeDuplicates.addEventListener('change', processText);
      dom.saveKey.addEventListener('click', saveApiKey);
      dom.apiKey.addEventListener('change', () => localStorage.setItem(API_KEY_STORAGE, dom.apiKey.value.trim()));

      dom.deckPicker.addEventListener('change', () => {
        state.selectedDeckIndex = parseInt(dom.deckPicker.value, 10) || 0;
      });

    // --- Init ---
    loadState();
    refreshDeckPicker();
    loadApiKey();
    updateRangeExtras();
    if (dom.wordInput.value) processText();
    updateSummary();
  </script>
</body>
</html>
