<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>French Custom Flashcards</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg: #0b1120;
      --panel: #0f172a;
      --accent: #22c55e;
      --accent-2: #38bdf8;
      --accent-hover: #16a34a;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --border: #1f2937;
      --card: linear-gradient(145deg, #111827, #0f172a);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: 'Poppins', system-ui, sans-serif;
      background: radial-gradient(circle at 15% 20%, rgba(34,197,94,0.10), transparent 30%),
                  radial-gradient(circle at 85% 0%, rgba(56,189,248,0.12), transparent 30%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    header {
      padding: 24px 28px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(15,23,42,0.8);
      position: sticky;
      top: 0;
      backdrop-filter: blur(8px);
      z-index: 2;
    }
    header a { color: var(--muted); text-decoration: none; font-weight: 600; }
    header a:hover { color: var(--text); }
    main { max-width: 1200px; margin: 0 auto; padding: 28px; }
    h1 { margin: 0 0 6px; letter-spacing: -0.02em; }
    p { margin: 0; color: var(--muted); }

    .tab-row { display: flex; gap: 10px; margin: 18px 0 24px; flex-wrap: wrap; }
    .tab-btn {
      border: 1px solid var(--border);
      background: rgba(15,23,42,0.75);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      min-width: 140px;
    }
    .tab-btn.active { background: linear-gradient(135deg, var(--accent), var(--accent-hover)); color: #0b1120; border: none; }

    .board { display: grid; grid-template-columns: 1.35fr 1fr; gap: 18px; }
    @media (max-width: 1024px) { .board { grid-template-columns: 1fr; } }

    .panel {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
    }
    .panel header { padding: 0; border: none; background: none; margin-bottom: 16px; }
    label { display: block; font-size: 13px; color: var(--muted); margin-bottom: 6px; }

    input[type="text"], select {
      width: 100%;
      border-radius: 10px;
      border: 1px solid var(--border);
      padding: 12px 14px;
      background: #0b1224;
      color: var(--text);
      font-size: 15px;
      outline: none;
      transition: border-color 0.2s;
    }
    input[type="text"]:focus, select:focus { border-color: var(--accent); }

    button { border: none; padding: 12px 14px; border-radius: 10px; font-weight: 700; cursor: pointer; font-family: inherit; }
    button.primary { background: linear-gradient(135deg, var(--accent), var(--accent-hover)); color: #0b1120; border: none; }
    button.secondary { background: transparent; color: var(--text); border: 1px solid var(--border); }
    button.ghost { background: transparent; color: var(--muted); border: 1px dashed var(--border); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }

    .input-row { display: grid; gap: 10px; grid-template-columns: 1fr auto; align-items: center; }
    .accent-container { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 10px; }
    .accent-group { display: flex; gap: 4px; background: rgba(0,0,0,0.2); padding: 4px; border-radius: 8px; border: 1px solid var(--border); }
    .accent-btn {
      padding: 0;
      width: 30px;
      height: 30px;
      background: rgba(255,255,255,0.05);
      border: 1px solid transparent;
      color: var(--text);
      border-radius: 6px;
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .accent-btn:hover { background: rgba(255,255,255,0.15); border-color: var(--muted); transform: translateY(-1px); }

    .actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; margin-top: 16px; }
    .pill { display: inline-flex; align-items: center; gap: 8px; padding: 8px 10px; background: rgba(56,189,248,0.12); border-radius: 10px; border: 1px solid rgba(56,189,248,0.3); color: var(--text); font-weight: 600; }

    .deck-list { display: grid; gap: 12px; margin-top: 16px; max-height: 520px; overflow-y: auto; padding-right: 5px; }
    .word-row { border: 1px solid var(--border); border-radius: 12px; padding: 14px; background: #0b1224; display: flex; flex-direction: column; gap: 8px; }
    .word-head { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
    .word-head h3 { margin: 0; font-size: 18px; color: var(--accent); }
    .tags { display: flex; gap: 8px; flex-wrap: wrap; }
    .definition-list { margin: 8px 0 0 0; padding-left: 18px; font-size: 14px; color: #cbd5e1; }
    .definition-list li { margin-bottom: 12px; line-height: 1.4; }
    .example-box { display: block; margin-top: 4px; padding-left: 8px; border-left: 2px solid var(--border); color: var(--muted); font-size: 13px; font-style: italic; }

    .card-shell { background: var(--panel); border: 1px solid var(--border); border-radius: 16px; padding: 20px; position: relative; min-height: 420px; display: flex; flex-direction: column; gap: 14px; }
    .card { background: var(--card); border-radius: 14px; padding: 20px 20px 16px; border: 1px solid var(--border); box-shadow: 0 16px 40px rgba(0,0,0,0.35); min-height: 300px; position: relative; display: flex; flex-direction: column; gap: 12px; height: auto; overflow: visible; }
    .card .face-label { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.08em; }
    .prompt { font-size: 40px; margin: 12px 0 8px; }
    .tagline { color: var(--muted); margin: 0 0 12px; }
    .back { margin-top: 12px; background: rgba(15,23,42,0.6); border: 1px dashed var(--border); border-radius: 12px; padding: 14px; }
    .detail-grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); }
    .reveal-block { perspective: 1200px; }
    .reveal-block .flip-inner {
      position: relative;
      background: #0d162a;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 16px;
      cursor: pointer;
      transform-style: preserve-3d;
      transition: transform 0.65s ease;
      min-height: 140px;
      box-shadow: 0 12px 26px rgba(0,0,0,0.25);
    }
    .reveal-block.revealed .flip-inner { transform: rotateY(180deg); }
    .reveal-block .face { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; backface-visibility: hidden; -webkit-backface-visibility: hidden; gap: 8px; text-align: center; padding: 16px; background: #0d162a; transform-style: preserve-3d; transition: opacity 0.35s ease; border-radius: 12px; }
    .reveal-block .face .label { font-size: 12px; color: var(--muted); text-transform: uppercase; letter-spacing: 0.06em; }
    .reveal-block .face .value { font-size: 22px; font-weight: 700; margin-top: 4px; }
    .reveal-block .face.front .value { color: rgba(226,232,240,0.7); }
    .reveal-block .face.back { transform: rotateY(180deg); opacity: 0; }
    .reveal-block.revealed .face.front { opacity: 0; }
    .reveal-block.revealed .face.back { opacity: 1; }
    .reveal-block button.sound { justify-self: flex-end; background: rgba(255,255,255,0.08); border: 1px solid var(--border); color: var(--text); border-radius: 8px; padding: 6px 8px; cursor: pointer; }
    .reveal-block.highlight .flip-inner { border-color: rgba(56,189,248,0.6); box-shadow: 0 12px 30px rgba(56,189,248,0.18); }
    .reveal-block.highlight .face.front { color: #bae6fd; }
    .reveal-block .subtext { margin-top: 8px; font-size: 14px; color: rgba(148,163,184,0.8); font-weight: 600; }
    .reveal-block.mini { min-height: 0; }
    .reveal-block.mini .flip-inner { min-height: 0; padding: 12px; }
    .reveal-block.mini .face .value { font-size: 16px; line-height: 1.4; }
    .mini-line { display: flex; gap: 6px; align-items: center; justify-content: flex-start; }
    .mini-line .label { color: rgba(148,163,184,0.9); font-weight: 600; font-size: 12px; }

    .grades { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 14px; }
    .grade-btn { border: none; padding: 12px; border-radius: 10px; cursor: pointer; font-weight: 700; color: #0b1120; }
    .grade-again { background: #f87171; }
    .grade-hard { background: #fbbf24; }
    .grade-medium { background: #34d399; }
    .grade-easy { background: #60a5fa; }
    .grade-good { background: #a78bfa; }
    .meta { color: var(--muted); margin-top: 8px; font-size: 14px; }

    .hidden { display: none; }
    .status-msg { margin-top: 10px; font-size: 13px; min-height: 20px; color: var(--muted); }
    .backup-panel { margin-top: 12px; padding: 12px; border: 1px dashed var(--border); border-radius: 12px; background: rgba(15,23,42,0.5); }
    .checkbox-list { display: grid; gap: 6px; margin: 10px 0; }
  </style>
</head>
<body>
  <header>
    <div>
      <div style="font-weight:700;">French Custom Flashcards</div>
      <small style="color: var(--muted);">Build your own decks and study them</small>
    </div>
    <a href="./index.html">‚Üê Back to menu</a>
  </header>

  <main>
    <div class="tab-row">
      <button class="tab-btn active" data-tab="build">Build Deck</button>
      <button class="tab-btn" data-tab="flashcards">Flashcards</button>
      <span class="pill" id="deckPill">Current deck: Unsaved</span>
    </div>

    <div class="board">
      <section class="panel" id="buildTab">
        <header>
          <h1>Build Deck</h1>
          <p>Add words, view saved decks, and keep editing.</p>
        </header>

        <form id="addForm">
          <label for="wordInput">Add a word</label>
          <div class="input-row">
            <input id="wordInput" type="text" placeholder="e.g. dois, plus, chien..." required autocomplete="off" />
            <button type="submit" class="primary">Add</button>
          </div>
          <div id="accentContainer" class="accent-container"></div>
          <div class="status-msg" id="status"></div>
        </form>

        <div class="actions">
          <button id="startDeck" class="secondary" disabled>‚ñ∂ Use as Current Deck</button>
          <button id="newDeck" class="ghost">New deck</button>
          <span id="countLabel" style="margin-left:auto; color: var(--muted);">0 cards</span>
        </div>

        <div class="actions">
          <div style="flex:1; display:grid; gap:8px;">
            <label for="saveName" style="margin:0;">Save deck as</label>
            <div class="input-row">
              <input id="saveName" type="text" placeholder="My verbs" />
              <button class="primary" type="button" id="saveDeck">Save deck</button>
            </div>
          </div>
        </div>

        <div class="actions">
          <div style="flex:1; display:grid; gap:6px;">
            <label for="deckSelect" style="margin:0;">Load saved deck</label>
            <select id="deckSelect"></select>
          </div>
          <div style="display:flex; gap:8px; align-items:center;">
            <button class="secondary" type="button" id="backupDecks">Backup decks</button>
            <button class="ghost" type="button" id="deleteDeck">Delete deck</button>
          </div>
        </div>

        <div class="backup-panel hidden" id="restorePanel">
          <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
            <strong>Select decks to restore</strong>
            <div style="display:flex; gap:8px; align-items:center;">
              <label style="display:flex; gap:6px; align-items:center; color:var(--muted);"><input type="checkbox" id="restoreAll" /> Import all</label>
              <button class="secondary" type="button" id="confirmRestore">Import selected</button>
            </div>
          </div>
          <div id="restoreList" class="checkbox-list"></div>
        </div>

        <div id="deckList" class="deck-list"></div>
      </section>

      <section class="panel hidden" id="flashcardsTab">
        <header>
          <h1>Flashcards</h1>
          <p>Study any deck you have saved with light spaced repetition.</p>
        </header>

        <div class="actions" style="align-items:flex-end; margin-bottom:12px;">
          <div style="flex:1; display:grid; gap:8px;">
            <label for="playDeckSelect" style="margin:0;">Choose deck to study</label>
            <select id="playDeckSelect"></select>
          </div>
          <div style="display:flex; gap:10px; align-items:center;">
            <div class="pill" id="duePill">0 due / 0 total</div>
            <button class="primary" type="button" id="startFlashcards">‚ñ∂ Start session</button>
          </div>
        </div>

        <div class="card-shell">
          <div class="card" id="card">
            <div class="face-label">Prompt</div>
            <div class="prompt" id="prompt">Build a deck to get started</div>
            <p class="tagline" id="tagline"></p>
            <div class="back hidden" id="back">
              <div class="face-label">Answer</div>
              <div class="detail-grid" id="detailGrid"></div>
              <div class="actions" style="margin-top:10px;">
                <button class="secondary" id="revealAll">Show all</button>
                <button class="secondary" id="speakBtn">üîä Hear it</button>
              </div>
            </div>
          </div>
          <div class="grades hidden" id="gradeRow">
            <button class="grade-btn grade-again" data-offset="2" data-action="again">Again</button>
            <button class="grade-btn grade-hard" data-offset="5" data-action="hard">Hard</button>
            <button class="grade-btn grade-medium" data-offset="10" data-action="medium">Medium</button>
            <button class="grade-btn grade-easy" data-offset="15" data-action="easy">Easy</button>
            <button class="grade-btn grade-good" data-offset="remove" data-action="good">Good</button>
          </div>
          <div class="meta" id="queueInfo"></div>
        </div>
      </section>
    </div>
  </main>

  <input type="file" id="restoreFile" accept="application/json" class="hidden" />

  <script>
    const storageKey = 'tempFrenchDecks-v1';
    const apiKeyStorageKey = 'tempFrenchFlashcardsGeminiKey';
    const srsStorageKey = 'tempFrenchSrs-v1';
    const workInProgressKey = '__wip';

    const geminiSystemInstruction = `change this text so it includes both an IPA and english pronuncation as well, and an English translation of the sentence in brackets:
[fl√¢neur <m> (noun) ///fl…ë.n≈ì Å/// +++flah-nur+++ | an aimless wanderer or stroller | Le fl√¢neur observait la ville sans se presser. (The stroller watched the city without hurrying.)]

If you detect an idiom then return idiom like this:
[prendre la mouche ///p Å…ëÃÉd Å la mu É/// +++prahn-druh lah moosh+++ | to take offence suddenly | Il a pris la mouche pour une remarque pourtant innocente. (He took offense at an innocent remark.)]

As well as the words seperately:
[prendre <na> (verb) ///p Å…ëÃÉd Å/// +++prahn-druh+++ | to take | Elle doit prendre le train t√¥t demain. (She has to take the train early tomorrow.)]
[la <f> (article) | ///la/// +++lah+++ | the (feminine singular) | La porte √©tait rest√©e ouverte. (The door had remained open.)]
[mouche <f> (noun) | ///mu É/// +++moosh+++ | fly (the insect) | Une mouche tournait autour de la lampe. (A fly was circling around the lamp.)]`;

    const dom = {
      status: document.getElementById('status'),
      list: document.getElementById('deckList'),
      input: document.getElementById('wordInput'),
      accentContainer: document.getElementById('accentContainer'),
      startBtn: document.getElementById('startDeck'),
      newDeckBtn: document.getElementById('newDeck'),
      count: document.getElementById('countLabel'),
      saveName: document.getElementById('saveName'),
      saveDeckBtn: document.getElementById('saveDeck'),
      deckSelect: document.getElementById('deckSelect'),
      deckPill: document.getElementById('deckPill'),
      playDeckSelect: document.getElementById('playDeckSelect'),
      startFlashcards: document.getElementById('startFlashcards'),
      duePill: document.getElementById('duePill'),
      restoreBtn: document.getElementById('backupDecks'),
      restorePanel: document.getElementById('restorePanel'),
      restoreList: document.getElementById('restoreList'),
      restoreFile: document.getElementById('restoreFile'),
      restoreAll: document.getElementById('restoreAll'),
      restoreConfirm: document.getElementById('confirmRestore'),
      tabButtons: document.querySelectorAll('.tab-btn'),
      buildTab: document.getElementById('buildTab'),
      flashTab: document.getElementById('flashcardsTab'),
      prompt: document.getElementById('prompt'),
      tagline: document.getElementById('tagline'),
      back: document.getElementById('back'),
      detailGrid: document.getElementById('detailGrid'),
      gradeRow: document.getElementById('gradeRow'),
      queueInfo: document.getElementById('queueInfo'),
      speakBtn: document.getElementById('speakBtn'),
      revealAll: document.getElementById('revealAll'),
      deleteDeck: document.getElementById('deleteDeck')
    };

    const accentGroups = [ ['√©', '√®', '√™', '√´'], ['√†', '√¢', '√¶', '√°'], ['√Æ', '√Ø', '√≠'], ['√¥', '≈ì', '√≥'], ['√π', '√ª', '√º', '√∫'], ['√ß', '√±'], ['¬´', '¬ª'] ];
    accentGroups.forEach(group => {
      const groupDiv = document.createElement('div');
      groupDiv.className = 'accent-group';
      group.forEach(char => {
        const btn = document.createElement('button');
        btn.textContent = char;
        btn.type = 'button';
        btn.className = 'accent-btn';
        btn.addEventListener('click', () => insertAccent(char));
        groupDiv.appendChild(btn);
      });
      dom.accentContainer.appendChild(groupDiv);
    });

    let state = loadDeckState();
    let srsState = loadSrsState();
    let quizQueue = [];
    let quizIndex = 0;
    let currentStyle = 'fr-en';

    function loadDeckState() {
      try {
        return JSON.parse(localStorage.getItem(storageKey)) || { currentDeck: [], savedDecks: {}, currentName: 'Unsaved' };
      } catch {
        return { currentDeck: [], savedDecks: {}, currentName: 'Unsaved' };
      }
    }
    function persistState() { localStorage.setItem(storageKey, JSON.stringify(state)); }
    function loadSrsState() {
      try {
        return JSON.parse(localStorage.getItem(srsStorageKey)) || {};
      } catch {
        return {};
      }
    }
    function persistSrsState() { localStorage.setItem(srsStorageKey, JSON.stringify(srsState)); }

    function updatePill() {
      const name = state.currentName || 'Unsaved';
      dom.deckPill.textContent = `Current deck: ${name}`;
    }

    function insertAccent(char) {
      const input = dom.input;
      const start = input.selectionStart;
      const end = input.selectionEnd;
      const text = input.value;
      input.value = text.substring(0, start) + char + text.substring(end);
      input.selectionStart = input.selectionEnd = start + 1;
      input.focus();
    }

    function loadApiKey() { return localStorage.getItem(apiKeyStorageKey) || ''; }
    function saveApiKey(key) { localStorage.setItem(apiKeyStorageKey, key.trim()); }

    function saveDeckToLibrary() {
      const name = (dom.saveName.value || '').trim();
      if (!name) { alert('Name your deck first.'); return; }
      state.savedDecks[name] = [...state.currentDeck];
      state.currentName = name;
      persistState();
      renderDeckSelect();
      renderPlayDeckSelect();
      updatePill();
      dom.status.textContent = `Saved as "${name}"`;
      setTimeout(() => dom.status.textContent = '', 2500);
    }

    function renderDeckSelect() {
      const select = dom.deckSelect;
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = state.savedDecks && Object.keys(state.savedDecks).length ? 'Select a deck' : 'No saved decks yet';
      select.appendChild(placeholder);
      Object.keys(state.savedDecks || {}).sort().forEach(name => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
      });
    }

    function deleteSelectedDeck(name) {
      if (!name || !state.savedDecks[name]) { alert('Select a saved deck to delete.'); return; }
      if (!confirm(`Delete "${name}"? This cannot be undone.`)) return;
      delete state.savedDecks[name];
      delete srsState[name];
      if (state.currentName === name) { state.currentName = 'Unsaved'; }
      persistState();
      persistSrsState();
      renderDeckSelect();
      renderPlayDeckSelect();
      updatePill();
      updateDuePill();
      dom.status.textContent = `Deleted deck "${name}".`;
      setTimeout(() => dom.status.textContent = '', 2500);
    }

    function renderPlayDeckSelect() {
      const select = dom.playDeckSelect;
      if (!select) return;
      const prev = select.value;
      select.innerHTML = '';
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Select a deck to study';
      select.appendChild(placeholder);
      if (state.currentDeck.length) {
        const opt = document.createElement('option');
        opt.value = workInProgressKey;
        const label = state.currentName === 'Unsaved' ? 'Work-in-progress deck' : `Work-in-progress: ${state.currentName}`;
        opt.textContent = label;
        select.appendChild(opt);
      }
      Object.keys(state.savedDecks || {}).sort().forEach((name) => {
        const opt = document.createElement('option');
        opt.value = name;
        opt.textContent = name;
        select.appendChild(opt);
      });
      select.value = Array.from(select.options).some((opt) => opt.value === prev) ? prev : '';
      updateDuePill();
    }

    function getDeckKey(name) { return name === workInProgressKey ? 'current' : name; }
    function getDeckCards(name) { return name === workInProgressKey ? state.currentDeck : (state.savedDecks[name] || []); }
    function cardId(card) { return card.id || card.term; }

    function getCardState(deckName, id) {
      const deckKey = getDeckKey(deckName);
      return (srsState[deckKey] || {})[id] || null;
    }

    function scheduleCard(deckName, id, grade) {
      const deckKey = getDeckKey(deckName);
      const now = Date.now();
      const deckState = srsState[deckKey] || {};
      const current = deckState[id] || { ease: 2.5, interval: 0, repetitions: 0, lapses: 0, due: now };
      const qualityMap = { again: 1, hard: 2, good: 3, easy: 4 };
      const quality = qualityMap[grade] || 3;
      const state = { ...current };

      if (quality < 2) {
        state.repetitions = 0;
        state.interval = quality === 1 ? 0.007 : 1;
        state.ease = Math.max(1.3, (state.ease ?? 2.5) - 0.2);
        state.lapses = (state.lapses ?? 0) + 1;
      } else {
        const ease = state.ease ?? 2.5;
        let newEase = ease + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        newEase = Math.max(1.3, newEase);
        state.ease = newEase;
        if (state.repetitions === 0) {
          state.interval = grade === 'easy' ? 3 : 1;
        } else if (state.repetitions === 1) {
          state.interval = grade === 'easy' ? 8 : 6;
        } else {
          state.interval = Math.round(state.interval * newEase);
        }
        if (grade === 'hard') state.interval = Math.max(1, Math.round(state.interval * 0.6));
        if (grade === 'easy') state.interval = Math.round(state.interval * 1.3);
        state.repetitions += 1;
      }

      const intervalMs = state.interval * 24 * 60 * 60 * 1000;
      state.due = now + Math.max(intervalMs, 10 * 60 * 1000);
      state.lastGrade = grade;
      srsState[deckKey] = { ...deckState, [id]: state };
      return state;
    }

    function getReviewQueue(deckName, cards) {
      const now = Date.now();
      const due = [];
      const fresh = [];
      cards.forEach((card) => {
        const id = cardId(card);
        const state = getCardState(deckName, id);
        if (!state) { fresh.push({ id, card, due: now }); }
        else if (state.due <= now) { due.push({ id, card, due: state.due }); }
      });
      due.sort((a, b) => a.due - b.due);
      fresh.sort((a, b) => a.card.term.localeCompare(b.card.term));
      return [...due, ...fresh];
    }

    function formatDueDate(timestamp) {
      const delta = timestamp - Date.now();
      if (delta <= 0) return 'Available now';
      const minutes = Math.max(1, Math.round(delta / 60000));
      if (minutes < 60) return `${minutes} min`;
      const hours = minutes / 60;
      if (hours < 24) return `${hours.toFixed(hours < 10 ? 1 : 0)} hr`;
      const days = hours / 24;
      if (days < 7) return `${days.toFixed(days < 3 ? 1 : 0)} days`;
      const weeks = days / 7;
      return `${weeks.toFixed(weeks < 3 ? 1 : 0)} weeks`;
    }

    function updateDuePill() {
      if (!dom.duePill || !dom.playDeckSelect) return;
      const deckName = dom.playDeckSelect.value || (state.currentDeck.length ? workInProgressKey : '');
      const cards = deckName ? getDeckCards(deckName) : [];
      if (!deckName || !cards.length) { dom.duePill.textContent = '0 due / 0 total'; return; }
      const now = Date.now();
      const stats = cards.reduce((acc, card) => {
        const st = getCardState(deckName, cardId(card));
        if (!st) acc.fresh += 1;
        else if (st.due <= now) acc.due += 1;
        else acc.waiting += 1;
        return acc;
      }, { due: 0, waiting: 0, fresh: 0 });
      const total = cards.length;
      const nextDue = cards
        .map((card) => getCardState(deckName, cardId(card))?.due)
        .filter(Boolean)
        .sort((a, b) => a - b)[0];
      dom.duePill.textContent = `${stats.due + stats.fresh} due / ${total} total${nextDue ? ` ‚Ä¢ next ${formatDueDate(nextDue)}` : ''}`;
    }

    function loadSelectedDeck(name) {
      if (!name || !state.savedDecks[name]) return;
      state.currentDeck = [...state.savedDecks[name]];
      state.currentName = name;
      persistState();
      renderList();
      renderPlayDeckSelect();
      updatePill();
      dom.status.textContent = `Loaded deck "${name}"`;
      setTimeout(() => dom.status.textContent = '', 2000);
    }

    function newDeck() {
      if (state.currentDeck.length && !confirm('Start a new deck? Save first if you need to keep these cards.')) return;
      state.currentDeck = [];
      state.currentName = 'Unsaved';
      persistState();
      renderList();
      renderPlayDeckSelect();
      updatePill();
    }

    function backupDecks() {
      const blob = new Blob([JSON.stringify({ savedDecks: state.savedDecks }, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'french-decks-backup.json';
      a.click();
      URL.revokeObjectURL(url);
    }

    function showRestoreOptions(data) {
      const decks = data.savedDecks || {};
      const names = Object.keys(decks);
      dom.restoreList.innerHTML = '';
      if (!names.length) {
        dom.restoreList.textContent = 'No decks found in backup.';
        return;
      }
      names.forEach(name => {
        const lbl = document.createElement('label');
        lbl.style.display = 'flex';
        lbl.style.gap = '6px';
        lbl.style.alignItems = 'center';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = name;
        lbl.append(cb, document.createTextNode(name));
        dom.restoreList.appendChild(lbl);
      });
      dom.restorePanel.classList.remove('hidden');
    }

    function importSelectedDecks(backup) {
      const names = Object.keys(backup.savedDecks || {});
      if (!names.length) return;
      const selected = dom.restoreAll.checked
        ? names
        : Array.from(dom.restoreList.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value);
      selected.forEach(name => { state.savedDecks[name] = backup.savedDecks[name]; });
      persistState();
      renderDeckSelect();
      renderPlayDeckSelect();
      dom.status.textContent = `Imported ${selected.length} deck(s).`;
      dom.restorePanel.classList.add('hidden');
      dom.restoreAll.checked = false;
      dom.restoreList.innerHTML = '';
      setTimeout(() => dom.status.textContent = '', 2500);
    }

    function renderList() {
      dom.list.innerHTML = '';
      dom.count.textContent = `${state.currentDeck.length} cards`;
      dom.startBtn.disabled = !state.currentDeck.length;
      renderPlayDeckSelect();
      if (!state.currentDeck.length) return;
      state.currentDeck.forEach((card, idx) => {
        const item = document.createElement('div');
        item.className = 'word-row';
        item.innerHTML = `
          <div class="word-head">
            <h3>${card.term}</h3>
            <div class="tags">
              ${card.pos ? `<span class="pill" style="background:rgba(34,197,94,0.15); border:1px solid rgba(34,197,94,0.35);">${card.pos}</span>` : ''}
              ${card.gender ? `<span class="pill" style="background:rgba(56,189,248,0.12); border:1px solid rgba(56,189,248,0.3);">${card.gender}</span>` : ''}
            </div>
          </div>
          <ul class="definition-list">
            ${(card.definitions || []).map(def => `<li>${def.text || ''}${def.example ? `<div class="example-box">${def.example}</div>` : ''}</li>`).join('')}
          </ul>
          <div class="actions" style="justify-content:flex-end;">
            <button class="secondary" type="button" data-remove="${idx}">Remove</button>
          </div>
        `;
        dom.list.appendChild(item);
      });
      dom.list.querySelectorAll('[data-remove]').forEach(btn => btn.addEventListener('click', () => { state.currentDeck.splice(parseInt(btn.dataset.remove,10), 1); persistState(); renderList(); }));
    }

    function renderCard(card) {
      dom.prompt.textContent = card.term;
      dom.tagline.textContent = 'Tap tiles to reveal details.';
      dom.back.classList.remove('hidden');
      dom.gradeRow.classList.remove('hidden');
      buildDetailBlocks(card);
      updateMeta();
    }

    function buildDetailBlocks(card) {
      const blocks = [];
      const meaningSubtexts = [];
      if (card.pos) meaningSubtexts.push(card.pos);
      blocks.push(createBlock('Meaning', (card.definitions?.[0]?.text) || '‚Äî', { highlightMeaning: true, subTexts: meaningSubtexts }));
      blocks.push(createPronBlock(card));
      if (card.gender) blocks.push(createBlock('Gender', card.gender));
      if (card.definitions?.[0]?.example) blocks.push(createBlock('Example', card.definitions[0].example));
      dom.detailGrid.innerHTML = '';
      blocks.forEach(b => dom.detailGrid.appendChild(b));
    }

    function createBlock(label, value, options = {}) {
      const { highlightMeaning = false, subTexts = null, size = 'regular' } = options;
      const subItems = Array.isArray(subTexts) ? subTexts.filter(Boolean) : [];
      const div = document.createElement('div');
      const sizeClass = size === 'mini' ? ' mini' : '';
      div.className = 'reveal-block masked' + (highlightMeaning ? ' highlight' : '') + sizeClass;
      div.tabIndex = 0;

      const inner = document.createElement('div');
      inner.className = 'flip-inner';

      const front = document.createElement('div');
      front.className = 'face front';
      const frontLabel = document.createElement('div');
      frontLabel.className = 'label';
      frontLabel.textContent = 'Front';
      const frontValue = document.createElement('div');
      frontValue.className = 'value';
      frontValue.textContent = label;
      front.append(frontLabel, frontValue);

      const back = document.createElement('div');
      back.className = 'face back';
      const backLabel = document.createElement('div');
      backLabel.className = 'label';
      backLabel.textContent = label;
      const backValue = document.createElement('div');
      backValue.className = 'value';
      backValue.textContent = value;
      subItems.forEach(text => {
        const sub = document.createElement('div');
        sub.className = 'subtext';
        sub.textContent = text;
        backValue.append(sub);
      });
      back.append(backLabel, backValue);

      inner.append(front, back);
      div.append(inner);
      div.addEventListener('click', () => revealTile(div));
      div.addEventListener('keypress', (e) => { if (e.key === 'Enter') revealTile(div); });
      return div;
    }

    function createPronBlock(card) {
      const container = document.createElement('div');
      container.className = 'reveal-block masked';
      container.tabIndex = 0;

      const inner = document.createElement('div');
      inner.className = 'flip-inner';

      const front = document.createElement('div');
      front.className = 'face front';
      const frontLabel = document.createElement('div');
      frontLabel.className = 'label';
      frontLabel.textContent = 'Front';
      const frontValue = document.createElement('div');
      frontValue.className = 'value';
      frontValue.textContent = 'Pronunciation';
      front.append(frontLabel, frontValue);

      const back = document.createElement('div');
      back.className = 'face back';
      const label = document.createElement('div');
      label.className = 'label';
      label.textContent = 'Pronunciation';
      const value = document.createElement('div');
      value.className = 'value';
      value.innerHTML = `${card.phonetic || ''}${card.ipa ? ` ¬∑ /${card.ipa}/` : ''}` || '‚Äî';
      const btn = document.createElement('button');
      btn.className = 'sound';
      btn.type = 'button';
      btn.textContent = 'üîä';
      btn.addEventListener('click', (e) => { e.stopPropagation(); speak(card.term); });
      back.append(label, value, btn);

      inner.append(front, back);
      container.append(inner);
      container.addEventListener('click', () => revealTile(container));
      container.addEventListener('keypress', (e) => { if (e.key === 'Enter') revealTile(container); });
      return container;
    }

    function revealTile(tile) { tile.classList.add('revealed'); tile.classList.remove('masked'); }

    function startSession() {
      const selected = dom.playDeckSelect.value || (state.currentDeck.length ? workInProgressKey : '');
      const deckCards = getDeckCards(selected);
      if (!selected || !deckCards.length) {
        dom.prompt.textContent = 'Select or build a deck to study.';
        dom.tagline.textContent = '';
        dom.back.classList.add('hidden');
        dom.gradeRow.classList.add('hidden');
        updateMeta();
        return;
      }
      const queue = getReviewQueue(selected, deckCards);
      if (!queue.length) {
        dom.prompt.textContent = 'No cards are due yet.';
        dom.tagline.textContent = 'Finish building or wait until cards come due.';
        dom.back.classList.add('hidden');
        dom.gradeRow.classList.add('hidden');
        updateMeta();
        return;
      }
      quizQueue = queue;
      quizIndex = 0;
      currentStyle = selected;
      nextCard();
      setActiveTab('flashcards');
    }

    function nextCard() {
      if (!quizQueue.length) { dom.prompt.textContent = 'Add cards to study'; dom.back.classList.add('hidden'); dom.gradeRow.classList.add('hidden'); dom.tagline.textContent = ''; dom.queueInfo.textContent = ''; return; }
      const entry = quizQueue[quizIndex % quizQueue.length];
      renderCard(entry.card);
    }

    function gradeCard(action) {
      if (!quizQueue.length) return;
      const entry = quizQueue[quizIndex % quizQueue.length];
      const gradeMap = { again: 'again', hard: 'hard', medium: 'good', easy: 'easy', good: 'easy' };
      const grade = gradeMap[action] || 'good';
      scheduleCard(currentStyle, entry.id, grade);
      quizQueue.splice(quizIndex % quizQueue.length, 1);
      quizIndex = 0;
      persistSrsState();
      updateDuePill();
      if (!quizQueue.length) {
        dom.prompt.textContent = 'Deck completed!';
        dom.tagline.textContent = 'Build or load another deck to keep going.';
        dom.back.classList.add('hidden');
        dom.gradeRow.classList.add('hidden');
        dom.queueInfo.textContent = '';
        return;
      }
      nextCard();
    }

    function updateMeta() { dom.queueInfo.textContent = `${quizQueue.length} card(s) left in this session.`; }

    function speak(word) { if (!('speechSynthesis' in window)) return; const utter = new SpeechSynthesisUtterance(word); utter.lang = 'fr-FR'; utter.rate = 0.95; window.speechSynthesis.speak(utter); }

    function parseGeminiFlashcards(text, originalTerm) {
      const matches = Array.from(text.matchAll(/\[(.*?)\]/gs)).map(m => m[1]);
      if (!matches.length) throw new Error('Unable to parse AI response. Try again.');
      return matches.map((entry, idx) => {
        let ipa = '';
        let phonetic = '';
        const ipaMatch = entry.match(/\/\/\/(.*?)\/\/\//);
        if (ipaMatch) { ipa = ipaMatch[1]; entry = entry.replace(ipaMatch[0], ''); }
        const phoneMatch = entry.match(/\+\+\+(.*?)\+\+\+/);
        if (phoneMatch) { phonetic = phoneMatch[1]; entry = entry.replace(phoneMatch[0], ''); }
        const parts = entry.split('|').map(p => p.trim()).filter(Boolean);
        const head = parts[0] || '';
        const meaning = parts[1] || '';
        const example = parts[2] || '';
        const genderMatch = head.match(/<(.*?)>/);
        const posMatch = head.match(/\((.*?)\)/);
        const term = head.replace(/<.*?>/g, '').replace(/\(.*?\)/g, '').trim() || `${originalTerm}-${idx + 1}`;
        return { id: Date.now() + idx, term, ipa, phonetic, pos: posMatch ? posMatch[1] : '', definitions: [{ text: meaning || 'Definition unavailable', example }], gender: genderMatch ? genderMatch[1] : '' };
      });
    }

    async function lookupWithGemini(term) {
      const apiKey = loadApiKey();
      if (!apiKey) throw new Error('Add your Google AI Studio API key at the bottom of the page.');
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-flash-latest:generateContent?key=${apiKey}`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({
          systemInstruction: { parts: [{ text: geminiSystemInstruction }] }, contents: [{ parts: [{ text: term }] }]
        })
      });
      const data = await response.json();
      if (data.error) throw new Error(data.error.message);
      const botText = data.candidates[0].content.parts[0].text;
      return parseGeminiFlashcards(botText, term);
    }

    async function lookupWord(term) {
      const cleanTerm = term.trim();
      const url = `https://en.wiktionary.org/w/api.php?action=parse&page=${encodeURIComponent(cleanTerm)}&prop=text&format=json&origin=*&redirects=1&disabletoc=1`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.error || !data.parse) throw new Error('Word not found on Wiktionary.');
      const html = data.parse.text['*'];
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const allHeads = Array.from(doc.querySelectorAll('h2'));
      let frenchHeader = allHeads.find(h => h.textContent.includes('French'));
      if (!frenchHeader) throw new Error('No "French" section found.');
      let startNode = frenchHeader.closest('.mw-heading') || frenchHeader;
      const frenchNodes = [];
      let sibling = startNode.nextElementSibling;
      while (sibling) {
        if (sibling.tagName === 'H2' || (sibling.classList.contains('mw-heading') && sibling.querySelector('h2'))) break;
        frenchNodes.push(sibling);
        sibling = sibling.nextElementSibling;
      }
      let ipa = '';
      let bestDefs = [];
      let bestPos = '';
      for (const node of frenchNodes) {
        const ipaEl = node.querySelector('.IPA');
        if (ipaEl && !ipa) { ipa = ipaEl.textContent.replace(/[\/\[\]]/g, '').trim(); }
      }
      const validPOS = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Preposition', 'Conjunction', 'Pronoun', 'Article', 'Determiner', 'Numeral', 'Participle'];
      for (let i = 0; i < frenchNodes.length; i++) {
        const node = frenchNodes[i];
        const headerText = node.textContent;
        const foundPos = validPOS.find(p => headerText.includes(p));
        const isHeader = ['H3', 'H4', 'H5'].includes(node.tagName) || node.querySelector('h3, h4, h5');
        if (isHeader && foundPos) {
          let defs = [];
          for (let j = i + 1; j < Math.min(i + 5, frenchNodes.length); j++) {
            const maybeList = frenchNodes[j];
            if (['H3', 'H4', 'H5'].includes(maybeList.tagName)) break;
            const lis = maybeList.querySelectorAll('ol > li');
            if (lis.length) {
              defs = Array.from(lis).slice(0, 3).map(li => ({
                text: li.textContent.replace(/\n+/g, ' ').trim(),
                example: (li.querySelector('ul li') || {}).textContent || ''
              }));
              break;
            }
          }
          if (defs.length) { bestDefs = defs; bestPos = foundPos; break; }
        }
      }
      return { id: Date.now(), term: cleanTerm, ipa, pos: bestPos, definitions: bestDefs.length ? bestDefs : [{ text: 'Definition unavailable', example: '' }], gender: '' };
    }

    document.getElementById('addForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const term = dom.input.value;
      if (!term) return;
      if (state.currentDeck.some(c => c.term.toLowerCase() === term.toLowerCase())) { dom.status.textContent = 'Word already in deck'; return; }
      dom.status.textContent = 'Fetching...';
      try {
        let cards;
        try { cards = await lookupWithGemini(term); dom.status.textContent = 'Added via Google AI Studio'; }
        catch (aiErr) { console.log('AI Failed (' + aiErr.message + '), switching to Wiktionary...'); cards = [await lookupWord(term)]; dom.status.textContent = 'Added via Wiktionary fallback'; }
        (Array.isArray(cards) ? cards : [cards]).forEach(card => { if (state.currentDeck.some(c => c.term.toLowerCase() === card.term.toLowerCase())) return; state.currentDeck.unshift(card); });
        persistState();
        renderList();
        dom.input.value = '';
        setTimeout(() => dom.status.textContent = '', 3000);
      } catch (err) {
        dom.status.textContent = err.message;
        console.error(err);
      }
    });

    dom.startBtn.addEventListener('click', () => { dom.playDeckSelect.value = workInProgressKey; updateDuePill(); startSession(); });
    dom.startFlashcards.addEventListener('click', startSession);
    dom.playDeckSelect.addEventListener('change', updateDuePill);
    dom.saveDeckBtn.addEventListener('click', saveDeckToLibrary);
    dom.deckSelect.addEventListener('change', (e) => loadSelectedDeck(e.target.value));
    dom.deleteDeck.addEventListener('click', () => deleteSelectedDeck(dom.deckSelect.value));
    dom.newDeckBtn.addEventListener('click', newDeck);
    dom.restoreBtn.addEventListener('click', backupDecks);

    dom.revealAll.addEventListener('click', () => { dom.detailGrid.querySelectorAll('.reveal-block.masked').forEach(el => revealTile(el)); });
    dom.speakBtn.addEventListener('click', () => { const entry = quizQueue[quizIndex % quizQueue.length]; if (entry?.card) speak(entry.card.term); });
    dom.gradeRow.addEventListener('click', (e) => { const btn = e.target.closest('.grade-btn'); if (!btn) return; gradeCard(btn.dataset.action); });

    dom.tabButtons.forEach(btn => btn.addEventListener('click', () => setActiveTab(btn.dataset.tab)));
    function setActiveTab(tab) {
      dom.tabButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
      dom.buildTab.classList.toggle('hidden', tab !== 'build');
      dom.flashTab.classList.toggle('hidden', tab !== 'flashcards');
    }

    dom.restoreConfirm.addEventListener('click', () => { if (!dom.restoreList.querySelector('input[type="checkbox"]')) return; const data = JSON.parse(dom.restoreConfirm.dataset.payload || '{}'); importSelectedDecks(data); });
    dom.restoreAll.addEventListener('change', (e) => { const checked = e.target.checked; dom.restoreList.querySelectorAll('input[type="checkbox"]').forEach(cb => { cb.checked = checked; }); });

    dom.restoreFile.addEventListener('change', async (e) => {
      const file = e.target.files?.[0];
      if (!file) return;
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        dom.restoreConfirm.dataset.payload = JSON.stringify(data);
        showRestoreOptions(data);
      } catch { alert('Invalid backup file.'); }
      dom.restoreFile.value = '';
    });

    const importBtn = document.createElement('button');
    importBtn.type = 'button';
    importBtn.textContent = 'Restore backup';
    importBtn.className = 'secondary';
    importBtn.addEventListener('click', () => dom.restoreFile.click());
    dom.restoreBtn.insertAdjacentElement('afterend', importBtn);

    (function setupApiKeyUI() {
      const container = document.createElement('section');
      container.className = 'panel';
      container.style.margin = '20px auto';
      container.style.maxWidth = '1200px';
      container.innerHTML = `
        <header style="display:flex; justify-content:space-between; align-items:center;">
          <div>
            <h3 style="margin:0;">Google AI Studio API Key</h3>
            <p style="margin:0; color:var(--muted);">Stored locally so you can refresh without losing it.</p>
          </div>
          <a href="https://aistudio.google.com/app/apikey" target="_blank" style="color:var(--accent); text-decoration:none; font-size:14px;">Get a key</a>
        </header>
        <div style="margin-top:12px; display:flex; gap:10px; align-items:center;">
          <input type="text" id="apiKeyInput" placeholder="Enter your Gemini API key" style="flex:1;" />
          <button class="primary" id="saveApiKey">Save Key</button>
        </div>
        <div id="apiKeyStatus" class="status-msg"></div>
      `;
      document.body.appendChild(container);
      const apiInput = container.querySelector('#apiKeyInput');
      const apiSave = container.querySelector('#saveApiKey');
      const apiStatus = container.querySelector('#apiKeyStatus');
      apiInput.value = loadApiKey();
      apiSave.addEventListener('click', () => { saveApiKey(apiInput.value); apiStatus.textContent = 'Saved locally.'; setTimeout(() => apiStatus.textContent = '', 3000); });
    })();

    renderDeckSelect();
    renderList();
    updatePill();
    updateDuePill();
  </script>
</body>
</html>
